<!DOCTYPE HTML>
<html lang="es">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Proyecto nubes de puntos</title>

    <!-- Fuente moderna (opcional) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

    <!-- SageCell -->
    <script src="https://sagecell.sagemath.org/static/jquery.min.js"></script>
    <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

    <script>
      $(function () {
        // 1) Biblioteca oculta, autoejecutada
        sagecell.makeSagecell({
          inputLocation: '#biblio',
          template: sagecell.templates.minimal,
          linked: true,
          linkKey: 'proyecto-poly',
          autoeval: true,
          hide: ["editor", "evalButton", "language", "permalink"]
        });

        // 2) Applets visibles
        sagecell.makeSagecell({
          inputLocation: '.compute-applet',
          template: sagecell.templates.minimal,
          linked: true,
          linkKey: 'proyecto-poly',
          evalButtonText: 'Ejecutar applet'
        });
      });
    </script>

<style>
  :root {
    --bg: #f3f4f6;              /* fondo general gris claro */
    --bg-card: #ffffff;         /* tarjetas blancas */
    --border-card: #e5e7eb;
    --accent: #2563eb;          /* azul principal */
    --accent-soft: rgba(37,99,235,0.08);
    --accent-soft-strong: rgba(37,99,235,0.16);
    --text-main: #111827;
    --text-muted: #6b7280;
    --radius-lg: 14px;
    --shadow-soft: 0 18px 40px rgba(15,23,42,0.12);
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    padding: 32px 16px 48px;
    font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background:
      radial-gradient(circle at top left, rgba(191,219,254,0.6) 0, transparent 45%),
      radial-gradient(circle at 80% 0, rgba(221,214,254,0.5) 0, transparent 45%),
      linear-gradient(to bottom, #f9fafb, #e5e7eb);
    color: var(--text-main);
  }

  .page {
    max-width: 960px;
    margin: 0 auto;
  }

  header {
    margin-bottom: 32px;
  }

  .title {
    font-size: clamp(2.2rem, 3vw, 2.7rem);
    font-weight: 600;
    letter-spacing: -0.03em;
    display: flex;
    align-items: center;
    gap: 0.6rem;
  }

  .title-badge {
    font-size: 0.75rem;
    padding: 0.18rem 0.6rem;
    border-radius: 999px;
    border: 1px solid rgba(148,163,184,0.6);
    color: var(--text-muted);
    background: rgba(255,255,255,0.9);
    backdrop-filter: blur(6px);
  }

  .subtitle {
    margin-top: 8px;
    font-size: 0.98rem;
    color: var(--text-muted);
  }

  .byline {
    margin-top: 4px;
    font-size: 0.85rem;
    color: var(--text-muted);
  }

  hr {
    border: none;
    border-top: 1px solid rgba(148,163,184,0.4);
    margin: 24px 0 32px;
  }

  section {
    margin-bottom: 32px;
  }

  h2 {
    font-size: 1.05rem;
    margin: 0 0 10px;
    font-weight: 600;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: #4b5563;
  }

  p {
    margin: 0 0 8px;
    font-size: 0.95rem;
    line-height: 1.6;
    color: var(--text-muted);
  }

  /* Tarjetas generales */

  .card {
    position: relative;
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-card);
    box-shadow: var(--shadow-soft);
    padding: 18px 18px 16px;
    margin-bottom: 28px;
    overflow: hidden;
    transition: transform 0.12s ease-out, box-shadow 0.12s ease-out;
  }

  .card::before {
    /* borde lateral de color suave */
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 3px;
    height: 100%;
    background: linear-gradient(to bottom, #2563eb, #22c55e);
    opacity: 0.75;
  }

  .card:hover {
    transform: translateY(-2px);
    box-shadow: 0 22px 55px rgba(15,23,42,0.18);
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 10px;
  }

  .card-title {
    font-size: 1.02rem;
    font-weight: 600;
  }

  .card-tag {
    font-size: 0.75rem;
    padding: 2px 8px;
    border-radius: 999px;
    background: var(--accent-soft);
    color: var(--accent);
  }

  .card-body {
    font-size: 0.92rem;
    color: var(--text-muted);
    margin-bottom: 10px;
  }

  .card-body ul {
    padding-left: 18px;
    margin: 6px 0;
  }

  .card-body li {
    margin-bottom: 4px;
  }

  /* Tarjetas específicamente de applet (pones class="card card--applet") */

  .card--applet::before {
    background: linear-gradient(to right, var(--accent-soft-strong), transparent);
    width: 100%;
    height: 4px;
  }

  .card--applet {
    padding-top: 20px;
  }

  /* -- Estilo ligero para SageCell (solo botón y salida) -- */

  .sagecell {
    margin-top: 10px;
  }

  .sagecell .sagecell_evalButton {
    position: relative;
    background: var(--accent);
    border-radius: 999px;
    border: none;
    padding: 6px 18px;
    font-size: 0.86rem;
    font-weight: 500;
    color: #ffffff;
    cursor: pointer;
    box-shadow: 0 8px 18px rgba(37,99,235,0.25);
    overflow: hidden;
    transition: transform 0.08s ease-out, box-shadow 0.08s ease-out,
                background 0.15s ease-out;
  }

  .sagecell .sagecell_evalButton::after {
    /* pequeño brillo diagonal animado */
    content: "";
    position: absolute;
    top: 0;
    left: -40%;
    width: 40%;
    height: 100%;
    background: linear-gradient(120deg, transparent, rgba(255,255,255,0.6), transparent);
    opacity: 0;
    transform: translateX(-100%);
    transition: opacity 0.2s ease-out, transform 0.4s ease-out;
  }

  .sagecell .sagecell_evalButton:hover {
    transform: translateY(-1px);
    box-shadow: 0 12px 26px rgba(37,99,235,0.35);
    background: #1d4ed8;
  }

  .sagecell .sagecell_evalButton:hover::after {
    opacity: 0.9;
    transform: translateX(220%);
  }

  .sagecell .sagecell_evalButton:active {
    transform: translateY(0);
    box-shadow: 0 4px 12px rgba(148,163,184,0.8);
  }

  .sagecell_output {
    margin-top: 10px;
    border-radius: 10px;
    border: 1px solid #e5e7eb;
    padding: 10px;
    background: #ffffff;
  }


  @media (max-width: 720px) {
    body {
      padding: 20px 12px 32px;
    }
    .card {
      padding: 14px 14px 10px;
    }
  }
</style>

  </head>

  <body>
    <!-- contenedor principal -->
    <div class="page">

      <!-- BIBLIOTECA OCULTA: se auto-ejecuta y deja todo en memoria -->
      <div id="biblio" style="display:none;">
        <script type="text/x-sage">


############################################################
# BIBLIOTECA
############################################################

from random import gauss, uniform
from numpy.linalg import *

def dist(p,q):
    return sqrt((p[0]-q[0])**2 + (p[1]-q[1])**2)

# alias para la función distancia que usas luego
def distancia(p,q):
    return dist(p,q)

def puntoMedio(p,q):
    return [(p[0]+q[0])/2,(p[1]+q[1])/2]

def areaSignada(a,b,c):
    return ((b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0]))/2

def enSegmento(p,s):
    if areaSignada(p,s[0],s[1])!=0:
        return false
    return float(dist(p,s[0]))+float(dist(p,s[1]))==float(dist(s[0],s[1]))

def enSegmentoII(p,s):
    if areaSignada(p,s[0],s[1])!=0:
        return false
    if s[0][0]<=p[0] and p[0]<=s[1][0] or s[0][0]>=p[0] and p[0]>=s[1][0]:
        if s[0][1]<=p[1] and p[1]<=s[1][1] or s[0][1]>=p[1] and p[1]>=s[1][1]:
            return true
    return false

def enTriangulo(p,t):
    a1=areaSignada(t[0],t[1],p)
    a2=areaSignada(t[1],t[2],p)
    a3=areaSignada(t[2],t[0],p)
    if a1>=0 and a2>=0 and a3>=0 or a1<=0 and a2<=0 and a3<=0:
        return true
    else:
        return false

def testInterseccionSegmentos(p,q):
    if (areaSignada(p[0],p[1],q[0])*areaSignada(p[0],p[1],q[1])<0 and
        areaSignada(q[0],q[1],p[0])*areaSignada(q[0],q[1],p[1])<0):
        return true
    else:
        if enSegmento(p[0],q) or enSegmento(p[1],q) or enSegmento(q[0],p) or enSegmento(q[1],p):
            return true
        else:
            return false

def interseccionRectas(r,s):
    x1=r[1][1]-r[0][1]
    y1=r[0][0]-r[1][0]
    x2=s[1][1]-s[0][1]
    y2=s[0][0]-s[1][0]
    if x1*y2-x2*y1==0:
        print("\n* Rectas paralelas. ", end="")
    else:
        z1=r[0][0]*r[1][1]-r[0][1]*r[1][0]
        z2=s[0][0]*s[1][1]-s[0][1]*s[1][0]
        x=(z1*y2-z2*y1)/(x1*y2-x2*y1)
        y=(x1*z2-x2*z1)/(x1*y2-x2*y1)
        return [x,y]

def circuncentroI(a,b,c):
    r=[[(a[0]+b[0])/2,(a[1]+b[1])/2],
       [(a[0]+b[0])/2+(a[1]-b[1]),((a[1]+b[1])/2)+b[0]-a[0]]]
    s=[[(a[0]+c[0])/2,(a[1]+c[1])/2],
       [(a[0]+c[0])/2+(a[1]-c[1]),((a[1]+c[1])/2)+c[0]-a[0]]]
    return interseccionRectas(r,s)

def enCirculoI(a,b,c,d):
    cc=circuncentroI(a,b,c)
    if dist(cc,d)<=dist(cc,a):
        return true
    else:
        return false

def enCirculo(a,b,c,d):
    t=matrix([[1,1,1],[a[0],b[0],c[0]],[a[1],b[1],c[1]]])
    dt=det(t)
    if dt==0:
        print("alineados")
        return
    m=matrix([[1,1,1,1],
              [a[0],b[0],c[0],d[0]],
              [a[1],b[1],c[1],d[1]],
              [a[0]**2+a[1]**2,b[0]**2+b[1]**2,
               c[0]**2+c[1]**2,d[0]**2+d[1]**2]])
    dm=det(m)
    return dt*dm<=0

def mediatriz(a,b):
    if a == b:
        return
    ab = [b[0]-a[0],b[1]-a[1]]
    abo = [-ab[1],ab[0]]
    m = puntoMedio(a,b)
    return [m, [m[0]+abo[0],m[1]+abo[1]]]

def circuncentroII(a,b,c):
    r=mediatriz(a,b)
    s=mediatriz(b,c)
    return interseccionRectas(r,s)

def areaPoligono(p):
    area = 0
    for i in range(1,len(p)-1):
        area += areaSignada(p[0],p[i],p[i+1])
    return area

def puntosEnCirculo(c,P):
    cont = 0
    for i in P:
        if enCirculo(c[0],c[1],c[2],i):
            cont +=1
    return cont  

def testInterseccionRectaSegmento(r,s):
    if areaSignada(r[0],r[1],s[0])*areaSignada(r[0],r[1],s[1])>0:
        return false
    else:
        return true

def circuncentro(a,b,c):
    mx=2*(b[0]-a[0])
    my=-2*(a[1]-b[1])
    m=b[0]^2-a[0]^2+b[1]^2-a[1]^2
    nx=2*(c[0]-a[0])
    ny=-2*(a[1]-c[1])
    n=c[0]^2-a[0]^2+c[1]^2-a[1]^2
    if mx*ny-nx*my==0:
        print("puntos alineados")
        return 
    x=(m*ny-n*my)/(mx*ny-nx*my)
    y=(mx*n-nx*m)/(mx*ny-nx*my)
    return [x,y]

def en_circulo(a,b,c,d):
    med_bc = mediatriz(b,c)
    med_bd = mediatriz(b,d)
    centro = testInterseccionRectaSegmento(med_bc, med_bd)
    radio = distancia(centro, b)
    return distancia(centro, a) <= radio

def Xmax(p): 
    return max(p)
    
def Xmin(p):
    return min(p)

def Ymax(p):
    return max(p, key=lambda x:[x[1],x[0]])
    
def Ymin(p):
    return min(p, key=lambda x:[x[1],x[0]])

def Vmax(p,v):
    return max(p, key=lambda x:[x[0]*v[0]+x[1]*v[1], -x[0]*v[1]+x[1]*v[0]])
   
def Vmin(p,v):
    return min(p, key=lambda x:[x[0]*v[0]+x[1]*v[1], -x[0]*v[1]+x[1]*v[0]])

def pendienteMinima(p):
    return min(p, key=lambda x: [x[1]/x[0] if x[0]!= 0 else float("inf"),
                                 dist([0,0],x)])
     
def pendienteMaxima(p):
    return max(p, key=lambda x: [x[1]/x[0] if x[0]!= 0 else float("inf"),
                                 dist([0,0],x)])

def ordenX(p):
    return sorted(p)

def ordenY(p):
    return sorted(p, key=lambda x:[x[1],x[0]])

def ordenX_bubble(p):
    for i in range(len(p)):
        for j in range(i+1,len(p)):
            if p[j][0]<p[i][0]:
                p[i],p[j] = p[j],p[i]
    return p

def ordenV(p,v):
    return sorted(p, key=lambda x: [x[0]*v[0]+x[1]*v[1], -x[0]*v[1]+x[1]*v[0]])

def ordenAngular(p,C):
    derecha=[]
    izquierda=[]
    superior=[]
    inferior=[]
    for i in p:
        if i[0]>C[0]:
            derecha.append(i)
        elif i[0]<C[0]:
            izquierda.append(i)
        elif i[0]==C[0] and i[1]>C[1]:
            superior.append(i)
        elif i[0]==C[0] and i[1]<C[1]:
            inferior.append(i)
    derecha=sorted(derecha,key=lambda x:[(x[1]-C[1])/(x[0]-C[0]),dist(x,C)])
    izquierda=sorted(izquierda,key=lambda x:[(x[1]-C[1])/(x[0]-C[0]),dist(x,C)])
    superior=sorted(superior)
    inferior=sorted(inferior)
    if C in p:
        return [C]+derecha+superior+izquierda+inferior
    else:
        return derecha+superior+izquierda+inferior

def poligonizacionXmonotona(P):
    L = ordenX(P)
    pmin = Xmin(P)
    pmax = Xmax(P)
    Linf = []
    Lsup = []
    for punto in L:
        if areaSignada(pmin,pmax,punto) >= 0:
            Lsup.append(punto)
        else:
            Linf.append(punto)
    return Linf + list(reversed(Lsup))

def poligonizacionYmonotona(P):
    L = ordenY(P)
    pmin = Ymin(P)
    pmax = Ymax(P)
    Lizq = []
    Lder = []
    for punto in L:
        if areaSignada(pmin,pmax,punto) >= 0:
            Lizq.append(punto)
        else:
            Lder.append(punto)
    return Lder + list(reversed(Lizq))

def poligonizacionVmonotona(P,v):
    L = ordenV(P,v)
    pmin = Vmin(P,v)
    pmax = Vmax(P,v)
    Lizq = []
    Lder = []
    for punto in L:
        if areaSignada(pmin,pmax,punto) >= 0:
            Lizq.append(punto)
        else:
            Lder.append(punto)
    return Lder + list(reversed(Lizq))

def poligonizacionEstrellada(P):
    C = [(P[0][0]+P[1][0]+P[2][0])/3, (P[0][1]+P[1][1]+P[2][1])/3]
    return ordenAngular(P,C), C

############################################################
# GENERADORES
############################################################

class CloudGenerator:
    def __init__(self, size):
        self.cloud_method = None
        self.size = size
        
    def generate(self, cloud_method, **params):
        self.cloud_method = cloud_method
        if cloud_method == "gaussian":
            return self.gaussian(**params)
        else:
            self.cloud_method = "random"
            return self.random(**params)

    def gaussian(self, mean_x=0, std_x=1, coef_x=1,
                 mean_y=0, std_y=1, coef_y=1):
        return [
            (coef_x * gauss(mean_x, std_x),
             coef_y * gauss(mean_y, std_y))
            for _ in range(self.size)
        ]
        
    def random(self, coef_x=1, lowerb_x=0, upperb_x=1,
               coef_y=1, lowerb_y=0, upperb_y=1):
        return [
            (coef_x * uniform(lowerb_x, upperb_x),
             coef_y * uniform(lowerb_y, upperb_y))
            for _ in range(self.size)
        ]

class PolygonGenerator:
    def __init__(self):
        self.polygon_method = None

    def generate(self, how, points):
        if len(points) > 0:
            self.polygon_method = how
            if how == "x_monotona":
                return poligonizacionXmonotona(points)
            elif how == "y_monotona":
                return poligonizacionYmonotona(points)
            else:
                self.polygon_method = "estrellada"
                return poligonizacionEstrellada(points)[0]
        else:
            return []

############################################################
# CLOUD
############################################################

class PointCloud:
    def __init__(self, size=150, cloud_generator=None, polygon_generator=None):
        self.size = size
        self.points = []
        self.cloud_method = None
        self.cloud_generator = cloud_generator if cloud_generator else CloudGenerator(size)
        self.polygon_method = None
        self.polygon_generator = polygon_generator if polygon_generator else PolygonGenerator()
        self.polygon = None
    
    def generate_cloud(self, how="gaussian", **params):
        self.points = self.cloud_generator.generate(how, **params)
        self.cloud_method = self.cloud_generator.cloud_method
        
    def generate_polygon(self, how="estrellada"):
        self.polygon = self.polygon_generator.generate(how, self.points)
        self.polygon_method = self.polygon_generator.polygon_method
        return Polygon(self.polygon)
    
    def plot_cloud(self, **kwargs):
        return point(self.points, **kwargs)
    
    def convex_hull(self):
        return ConvexPolygon.from_points(self.points)

############################################################
# POLÍGONOS
############################################################
class Polygon:
    def __init__(self, points):
        self.points = list(points)
        
    def is_convex_point(self, idx):
        points = self.points
        vl = (idx-1) % len(points)
        vr = (idx+1) % len(points)
        return areaSignada(points[vl], points[idx], points[vr]) >= 0
    
    def is_convex(self):
        self.convex_steps = [] 
        for idx in range(len(self.points)):
            result = self.is_convex_point(idx)
            self.convex_steps.append({
                "idx": idx,
                "point": self.points[idx],
                "convex": result
            })

            if not result:
                return False

        return True
    
    def plot(self, polygon_color='blue', alpha=0.3,
             point_color='blue', size=10):
        polygon_data = {'color': polygon_color, 'alpha': alpha}
        points_data = {'color': point_color, 'size': size}
        return (point(self.points,
                      color=points_data["color"],
                      size=points_data["size"])
                + polygon(self.points,
                          color=polygon_data["color"],
                          alpha=polygon_data["alpha"]))

    def convex_hull(self):
        return ConvexPolygon.from_points(self.points)
    
    def point_in_polygon(self, point):
        P = self.points
        m = max(P)
        M = [m[0]+1,m[1]+0.001*random()]
        if q in P:
            sol = true
        else:
            cont=0
            for i in range(len(P)):
                if testInterseccionSegmentos([M,q],[P[i-1],P[i]]):
                    cont+=1
            if cont%2==0:
                sol=false
            else:
                sol=true
        return sol


class ConvexPolygon(Polygon):
    def __init__(self, points):
        super().__init__(points)

    @classmethod
    def from_points(cls, points):
        hull_points = cls.graham(points)
        return cls(hull_points)

    @staticmethod
    def graham(points):
        P = list(points)
        if len(P) < 3:
            return P

        O = Xmin(P)               
        Q = ordenAngular(P, O)      

        i = 1
        while i < len(Q) - 1:
            if areaSignada(Q[(i-1) % len(Q)], Q[i], Q[(i+1) % len(Q)]) < 0:
                Q.pop(i)
                if i > 0:
                    i -= 1
            else:
                i += 1
        return Q
    
    def point_in_convex(self, p):
        P = self.points
        n = len(P)
        if n < 3:
            return false
        ref = None
        
        for i in range(n):
            a = P[i]
            b = P[(i+1) % n]
            s = areaSignada(a, b, p)
            if s == 0:
                if enSegmento(p, [a, b]):
                    return true
                else:
                    continue
            if not ref:
                ref = s
            else:
                if s * ref < 0:
                    return false
        return true


class PolygonHandler:
    def __init__(self, max_length=10):
        self.polygons = []
        self.max_length = max_length
        self.selected_index = None

    def add_polygon(self, polygon):
        if len(self.polygons) >= self.max_length:
            # quitamos el primero
            self.polygons.pop(0)

            # si había uno seleccionado, su índice se desplaza
            if self.selected_index is not None:
                self.selected_index -= 1
                if self.selected_index < 0 or self.selected_index >= len(self.polygons):
                    self.selected_index = None

        self.polygons.append(polygon)

    def get_next(self):
        if not self.polygons:
            return None
        p = self.polygons.pop(0)
        # reajustar selección si hace falta
        if self.selected_index is not None:
            if self.selected_index == 0:
                self.selected_index = None
            else:
                self.selected_index -= 1
        return p

    def peek(self):
        if not self.polygons:
            return None
        return self.polygons[0]

    def __len__(self):
        return len(self.polygons)
    
    def clean(self):
        self.polygons = []
        self.selected_index = None
        
    def select_polygon(self, idx):
        # idx es 1-based
        if 1 <= idx <= len(self.polygons):
            self.selected_index = idx - 1
            return self.polygons[self.selected_index]
        else:
            self.selected_index = None
            return None

    def get_selected(self):
        if self.selected_index is None:
            return None
        if 0 <= self.selected_index < len(self.polygons):
            return self.polygons[self.selected_index]
        # por si se ha desfasado el índice
        self.selected_index = None
        return None

handler = PolygonHandler()
selected_point = None
        </script>
      </div>

      <header>
        <div class="title">
          Nubes de puntos interactivas
          <span class="title-badge">SageMath · Geometría computacional</span>
        </div>
        <p class="subtitle">
          Exploración visual de nubes de puntos generadas aleatoriamente, con distribución gaussiana o uniforme.
        </p>
        <p class="byline">Por TuNombre · <span style="opacity:0.7;">Universidad / Curso</span></p>
      </header>

      <hr>

      <section>
        <h2>Introducción</h2>
        <p>
          En esta página se estudia la generación de nubes de puntos en el plano mediante distintas distribuciones
          de probabilidad. El objetivo es disponer de un entorno gráfico sencillo para experimentar con los parámetros
          y observar el comportamiento geométrico de los datos.
        </p>
      </section>

      <section>
        <h2>Instrucciones</h2>
        <p>
          Usa el primer applet para generar una nube de puntos. Puedes elegir el número de puntos, el tipo de
          distribución y los parámetros de la gaussiana. El segundo applet se reservará para futuros experimentos
          (por ejemplo, el estudio de polígonos).
        </p>
      </section>

      <!-- APPLET 1 -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 1 · Generador de polígonos</div>
            <span class="card-tag">Generador</span>
          </div>
          <div class="card-body">
            <p>
              Ajusta el número de puntos y elige entre distribución <b>gaussiana</b> o <b>aleatoria uniforme</b>.
            </p>
          </div>

          <div class="compute-applet" id="applet1">
            <script type="text/x-sage">
current_pc  = None
current_P   = None
last_params = None

@interact(layout=dict(
    top=[
        ['n_puntos'],
        ['metodo', 'poligo', 'actualizar']
    ]
))
def applet_nube(
    n_puntos = slider(10, 500, 10, default=10,
                      label="N puntos"),
    metodo   = selector(["gaussian", "random"],
                        label="Método"),
    poligo   = selector(["Graham", "Monótono x", "Monótono y", "Estrellado"],
                        label="Poligonización"),
    actualizar = checkbox(True, label="Actualizar")
):
    global current_pc, current_P, last_params

    params = (int(n_puntos), str(metodo), str(poligo))

    # Siempre generamos la primera vez (current_pc is None),
    # después solo si "Actualizar" está marcado y cambian los parámetros.
    need_regen = (current_pc is None) or (actualizar and params != last_params)

    if need_regen:
        pc = PointCloud(size=n_puntos)
        pc.generate_cloud(metodo)

        if poligo == "Estrellado":
            P = pc.generate_polygon()
        elif poligo == "Monótono x":
            P = pc.generate_polygon("x_monotona")
        elif poligo == "Monótono y":
            P = pc.generate_polygon("y_monotona")
        else:   # Graham
            P = pc.convex_hull()

        current_pc  = pc
        current_P   = P
        last_params = params
        handler.add_polygon(P)
    else:
        pc = current_pc
        P  = current_P

    g  = point(pc.points, size=15, rgbcolor=(0.10, 0.20, 0.80))
    g += polygon(P.points, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
    show(g, aspect_ratio=1, axes=True, figsize=5)

            </script>
          </div>
        </div>
      </section>

      <!-- APPLET 2 SELECCIÓN DE POLÍGONO -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 2 · Selector de polígono</div>
            <span class="card-tag">Selector</span>
          </div>
          <div class="card-body">
            <p>
              Selecciona el polígono con el que quieras trabajar
            </p>
          </div>

          <div class="compute-applet" id="applet2">
            <script type="text/x-sage">

s = f"Has guardado {len(handler)} polígono{"" if len(handler) == 1 else "s"}"
pretty_print(html(f"<h3 style='text-align:center;'>{s}</h3>"))
@interact
def applet_2(
    idx = slider(1, 10, 1, default=1,
                 label="Índice de polígono (1–10)")
):
    # seleccionar en el handler (1-based) y dejarlo marcado como seleccionado
    P = handler.select_polygon(idx)

    if P is None:
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "No hay polígono almacenado en esa posición."
            "</span>"
        ))
        return

    g = polygon(P.points, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
    g += point(P.points, size=15, rgbcolor=(0.10, 0.20, 0.80))
    g += line(P.points + [P.points[0]],
              rgbcolor=(0.10, 0.20, 0.60),
              thickness=1)
    show(g, aspect_ratio=1, axes=False, figsize=5)

            </script>
          </div>
        </div>
      </section>

      <section>
        <h2>Discusión</h2>
        <p>
            SEPARADOR
        </p>
      </section>

      <!-- APPLET 3  -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 3 · Análisis de convexidad</div>
            <span class="card-tag">Geometría</span>
          </div>
          <div class="card-body">
            <p>
              BODY CARD
            </p>
          </div>

          <div class="compute-applet" id="applet3">
            <script type="text/x-sage">


P = handler.get_selected()

if P is None:
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "No hay seleccionado ningún polígono"
        "</h3>"
    ))

    @interact
    def ver_pasos_convexidad():
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "Selecciona primero un polígono en el Applet 2."
            "</span>"
        ))

else:
    es_convexo = P.is_convex()
    s = "Convexo" if es_convexo else "No convexo"
    pretty_print(html(f"<h3 style='text-align:center;'>{s}</h3>"))

    n = len(P.points)
    pasos_pre = []
    for paso in P.convex_steps:
        idx = paso["idx"]
        pt = paso["point"]
        convex = paso["convex"]
        vl = (idx-1) % n
        vr = (idx+1) % n
        pt_left = P.points[vl]
        pt_right = P.points[vr]
        center_color = "green" if convex else "red"
        pasos_pre.append((idx, pt, pt_left, pt_right, center_color))

    @interact
    def ver_pasos_convexidad(
        k = slider(0, len(P.convex_steps)-1, 1, 0, label="Paso")
    ):
        idx, pt, pt_left, pt_right, center_color = pasos_pre[k]

        g  = polygon(P.points, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
        g += line(P.points + [P.points[0]],
                  rgbcolor=(0.10, 0.20, 0.60),
                  thickness=1)
        g += point(pt_left,  size=30, color='blue')
        g += point(pt_right, size=30, color='blue')
        g += point(pt, size=30, color=center_color)
        g += line([pt_left, pt, pt_right], color=center_color, thickness=1)

        show(g, aspect_ratio=1)


            </script>
          </div>
        </div>
      </section>

      <section>
        <h2>Discusión</h2>
        <p>
            SEPARADOR
        </p>
      </section>

      <!-- APPLET 4  -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 4 · Selector de punto</div>
            <span class="card-tag">Selector</span>
          </div>
          <div class="card-body">
            <p>
              BODY CARD
            </p>
          </div>

<div class="compute-applet" id="applet4">
  <script type="text/x-sage">
P = handler.get_selected()

if P is None:
    # Mensaje general
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "No hay seleccionado ningún polígono"
        "</h3>"
    ))

    # Interact “dummy” que solo muestra un recordatorio
    @interact
    def ver_pasos_convexidad():
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "Selecciona primero un polígono en el Applet 2."
            "</span>"
        ))
else:
  @interact
  def applet_4(
      x = slider(-3, 3, 0.01, default=-3, label="x"),
      y = slider(-3, 3, 0.01, default=-3, label="y")
  ):
      global selected_point

      # Redondeo (2 decimales)
      xr = round(float(x), 2)
      yr = round(float(y), 2)
      selected_point = (xr, yr)

      # Dibujo del polígono + punto seleccionado
      g  = polygon(P.points, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
      g += line(P.points + [P.points[0]],
                rgbcolor=(0.10, 0.20, 0.60),
                thickness=1)
      g += point([selected_point], size=30, rgbcolor='red')

      show(g, aspect_ratio=1, axes=True, figsize=5,
          xmin=-3, xmax=3, ymin=-3, ymax=3)

      # Texto bonito
      pretty_print(html(
          f"<div style='text-align:center; font-size:1.0rem;'>"
          f"Punto seleccionado: <b>({xr:.2f}, {yr:.2f})</b>"
          f"</div>"
      ))

  </script>
</div>
      </section>


      <section>
        <h2>Discusión</h2>
        <p>
            SEPARADOR
        </p>
      </section>

      <!-- APPLET 5  -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 5 · Punto en polígono</div>
            <span class="card-tag">Geometría</span>
          </div>
          <div class="card-body">
            <p>
              BODY CARD
            </p>
          </div>

<div class="compute-applet" id="applet5">
  <script type="text/x-sage">

P = handler.get_selected()

# intentar recuperar el punto seleccionado
try:
    q = selected_point
except NameError:
    q = None

# ========== DUMMY: falta polígono o falta punto ==========
if P is None or q is None:
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "Selecciona un polígono (Applet 2) y un punto (Applet 4)."
        "</h3>"
    ))

    @interact
    def applet_punto_en_poligono_dummy():
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "No hay datos suficientes para ejecutar el algoritmo."
            "</span>"
        ))
else:
    es_convexo = P.is_convex()
    n = len(P.points)
    res = P.point_in_polygon(q)

    texto_res = "INTERIOR" if res else "EXTERIOR"

    pretty_print(html(
        "<h3 style='text-align:center;'>"
        + ("Polígono convexo" if es_convexo else "Polígono no convexo")
        + " · Resultado final: " + texto_res +
        "</h3>"
    ))
    
    if es_convexo:
        tri_data = []              
        ref = None
        sign_changed = False

        for i in range(n):
            a = P.points[i]
            b = P.points[(i+1) % n]
            s = areaSignada(a, b, q)

            if s == 0:
                color = "green"
                tri = [a, b, q]
                interior_hasta_aqui = not sign_changed
                tri_data.append((tri, color, interior_hasta_aqui))
                continue

            if ref is None:
                ref = s
            else:
                if ref * s < 0:
                    sign_changed = True

            color = "green" if s >= 0 else "orange"
            tri  = [a, b, q]
            interior_hasta_aqui = not sign_changed
            tri_data.append((tri, color, interior_hasta_aqui))

            if sign_changed:
                break

        max_k = len(tri_data)
    else:
        max_k = n

    @interact
    def applet_punto_en_poligono(
        k = slider(0, max_k, 1, default=0, label="Paso")
    ):
        g  = polygon(P.points, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
        g += line(P.points + [P.points[0]],
                  rgbcolor=(0.10, 0.20, 0.60),
                  thickness=1)
        g += point([q], size=30, rgbcolor='red')

        if es_convexo:
            # ------- CASO CONVEXO -------
            for i in range(k):
                tri, col, interior_hasta_aqui = tri_data[i]
                g += polygon(tri, alpha=0.35, color=col)
                g += line([q, tri[0]], color=col, thickness=1)
                g += line([q, tri[1]], color=col, thickness=1)

            show(g, aspect_ratio=1, axes=True, figsize=5)

            if k == 0:
                dentro = True   # al inicio lo consideramos interior
            else:
                dentro = tri_data[k-1][2]

            msg = "Tras {} paso(s) el punto es <b>{}</b> respecto al polígono.".format(
                k,
                "INTERIOR" if dentro else "EXTERIOR"
            )
            pretty_print(html(
                f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
            ))

        else:
            # ------- CASO NO CONVEXO (ray casting) -------
            Ppts = P.points
            m = max(Ppts)
            M = [m[0] + 1, m[1] + 0.001]
            g += point(m, color="blue")
            g += point(M, color="blue")
            g += line([m, M], linestyle="--")

            g += line([M, q], color='black', linestyle="--", thickness=1)

            cont = 0
            for i in range(k):
                a = Ppts[i-1]
                b = Ppts[i]
                if testInterseccionSegmentos([M, q], [a, b]):
                    cont += 1
                    g += line([a, b], color='orange', thickness=2)
                else:
                    g += line([a, b], color='green', thickness=2)

            show(g, aspect_ratio=1, axes=True, figsize=5)

            dentro = (cont % 2 == 1)
            msg = (
                f"Ray casting con los primeros {k} lados: "
                f"<b>{cont}</b> intersecciones. "
            )
            msg += "El punto es <b>INTERIOR</b>." if dentro else "El punto es <b>EXTERIOR</b>."
            pretty_print(html(
                f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
            ))
  </script>
</div>
      </section>

    <section>
        <h2>Discusión</h2>
        <p>
            SEPARADOR
        </p>
      </section>

      <!-- APPLET 7  -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 7 · Área del polígono</div>
            <span class="card-tag">Geometría</span>
          </div>
          <div class="card-body">
            <p>
              BODY CARD
            </p>
          </div>

<div class="compute-applet" id="applet7">
  <script type="text/x-sage">
P = handler.get_selected()

# ========== DUMMY: falta polígono ==========
if P is None:
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "No hay seleccionado ningún polígono."
        "</h3>"
    ))

    @interact
    def applet_area_dummy():
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "Selecciona primero un polígono en el Applet 2."
            "</span>"
        ))

else:
    # ----------------------------------------------------
    # PRECÁLCULO DE TRIÁNGULOS Y ÁREAS (fuera del interact)
    # ----------------------------------------------------
    pts = P.points
    n   = len(pts)

    if n < 3:
        pretty_print(html(
            "<h3 style='text-align:center;'>"
            "El polígono tiene menos de 3 puntos."
            "</h3>"
        ))

        @interact
        def applet_area_dummy2():
            pretty_print(html(
                "<span style='font-size:0.9rem; color:#666;'>"
                "Necesitas al menos un triángulo para calcular el área."
                "</span>"
            ))
    else:
        base = pts[0]
        step_data   = []   # (triángulo, área_signada, área_acumulada, color)
        acum = 0

        for i in range(1, n-1):
            a = pts[i]
            b = pts[i+1]
            s = areaSignada(base, a, b)      # área signada de este triángulo
            acum += s                       # acumulamos

            color = "green" if s >= 0 else "orange"
            tri   = [base, a, b]
            step_data.append((tri, s, acum, color))

        max_k       = len(step_data)
        area_final  = acum
        area_abs    = abs(acum)

        # Mensaje de resumen encima del applet
        pretty_print(html(
            f"<h3 style='text-align:center;'>"
            f"Área total = {area_abs:.4f}"
            f"</h3>"
        ))

        @interact
        def applet_area(
            k = slider(0, max_k, 1, default=0, label="Paso")
        ):
            # Dibujo base: polígono
            g  = polygon(pts, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
            g += line(pts + [pts[0]],
                      rgbcolor=(0.10, 0.20, 0.60),
                      thickness=1)

            # Añadimos, hasta el paso k, los triángulos
            area_parcial = 0
            for i in range(k):
                tri, s, acum_i, col = step_data[i]
                g += polygon(tri, alpha=0.35, color=col)
                g += line(tri + [tri[0]], color=col, thickness=1)
                area_parcial = acum_i

            show(g, aspect_ratio=1, axes=True, figsize=5)

            # Texto explicativo bajo la figura
            if k == 0:
                msg = (
                    "Sin triángulos aún: área parcial = 0.0000"
                )
            else:
                msg = (
                    f"Tras {k} triángulo(s): "
                    f"área signada parcial = <b>{area_parcial:.4f}</b>, "
                )

            pretty_print(html(
                f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
            ))

  </script>
</div>
      </section>


      <hr>
      <p style="font-size:0.8rem; color:var(--text-muted);">
        Modificado por última vez: dd/mm/aaaa.
      </p>
    </div>
  </body>
</html>

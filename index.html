<!DOCTYPE HTML>
<html lang="es">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Proyecto nubes de puntos</title>


    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=DM+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">


    <!-- SageCell -->
    <script src="https://sagecell.sagemath.org/static/jquery.min.js"></script>
    <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

    <script>
      $(function () {
        // 1) Biblioteca oculta, autoejecutada
        sagecell.makeSagecell({
          inputLocation: '#biblio',
          template: sagecell.templates.minimal,
          linked: true,
          linkKey: 'proyecto-poly',
          autoeval: true,
          hide: ["editor", "evalButton", "language", "permalink"]
        });

        // 2) Applets visibles
        sagecell.makeSagecell({
          inputLocation: '.compute-applet',
          template: sagecell.templates.minimal,
          linked: true,
          linkKey: 'proyecto-poly',
          evalButtonText: 'Ejecutar applet'
        });
      });
    </script>

<style>
  :root {
    --bg: #f3f4f6;              /* fondo general gris claro */
    --bg-card: #ffffff;         /* tarjetas blancas */
    --border-card: #e5e7eb;
    --accent: #2563eb;          /* azul principal */
    --accent-soft: rgba(37,99,235,0.08);
    --accent-soft-strong: rgba(37,99,235,0.16);
    --text-main: #111827;
    --text-muted: #6b7280;
    --radius-lg: 14px;
    --shadow-soft: 0 18px 40px rgba(15,23,42,0.12);
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    padding: 32px 16px 48px;
    font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background:
      radial-gradient(circle at top left, rgba(191,219,254,0.6) 0, transparent 45%),
      radial-gradient(circle at 80% 0, rgba(221,214,254,0.5) 0, transparent 45%),
      linear-gradient(to bottom, #f9fafb, #e5e7eb);
    color: var(--text-main);
  }

  .page {
    max-width: 960px;
    margin: 0 auto;
  }

  header {
    margin-bottom: 32px;
  }

  .title {
    font-size: clamp(2.2rem, 3vw, 2.7rem);
    font-weight: 600;
    letter-spacing: -0.03em;
    display: flex;
    align-items: center;
    gap: 0.6rem;
  }

  .title-badge {
    font-size: 0.75rem;
    padding: 0.18rem 0.6rem;
    border-radius: 999px;
    border: 1px solid rgba(148,163,184,0.6);
    color: var(--text-muted);
    background: rgba(255,255,255,0.9);
    backdrop-filter: blur(6px);
  }

  .subtitle {
    margin-top: 8px;
    font-size: 0.98rem;
    color: var(--text-muted);
  }

  .byline {
    margin-top: 4px;
    font-size: 0.85rem;
    color: var(--text-muted);
  }

  hr {
    border: none;
    border-top: 1px solid rgba(148,163,184,0.4);
    margin: 24px 0 32px;
  }

  section {
    margin-bottom: 32px;
  }

  h2 {
    font-size: 1.05rem;
    margin: 0 0 10px;
    font-weight: 600;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: #4b5563;
  }

  p {
    margin: 0 0 8px;
    font-size: 0.95rem;
    line-height: 1.6;
    color: var(--text-muted);
  }

  /* Tarjetas generales */

  .card {
    position: relative;
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-card);
    box-shadow: var(--shadow-soft);
    padding: 18px 18px 16px;
    margin-bottom: 28px;
    overflow: hidden;
    transition: transform 0.12s ease-out, box-shadow 0.12s ease-out;
  }

  .card::before {
    /* borde lateral de color suave */
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 3px;
    height: 100%;
    background: linear-gradient(to bottom, #2563eb, #22c55e);
    opacity: 0.75;
  }

  .card:hover {
    transform: translateY(-2px);
    box-shadow: 0 22px 55px rgba(15,23,42,0.18);
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 10px;
  }

  .card-title {
    font-size: 1.02rem;
    font-weight: 600;
  }

  .card-tag {
    font-size: 0.75rem;
    padding: 2px 8px;
    border-radius: 999px;
    background: var(--accent-soft);
    color: var(--accent);
  }

  .card-body {
    font-size: 0.92rem;
    color: var(--text-muted);
    margin-bottom: 10px;
  }

  .card-body ul {
    padding-left: 18px;
    margin: 6px 0;
  }

  .card-body li {
    margin-bottom: 4px;
  }


  .intro-card {
    margin-bottom: 32px;
  }

  /* === Teoría desplegable ==================================== */

  .theory-card {
    padding: 0;              
    overflow: hidden;
  }

  .theory-details {
    border-radius: var(--radius-lg);
  }

  .theory-summary {
    list-style: none;
    display: flex;
    align-items: center;
    gap: 0.6rem;
    padding: 14px 18px;
    cursor: pointer;
    user-select: none;
  }

  .theory-details[open] .theory-summary {
    border-bottom: 1px solid var(--border-card);
    background: radial-gradient(circle at top left,
                rgba(148,163,184,0.18), transparent 60%);
  }

  .theory-summary::-webkit-details-marker {
    display: none;
  }

  .theory-icon {
    width: 22px;
    height: 22px;
    border-radius: 999px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.85rem;
    font-weight: 600;
    background: var(--accent-soft);
    color: var(--accent);
    flex-shrink: 0;
  }

  .theory-title {
    font-size: 0.95rem;
    font-weight: 600;
  }

  .theory-chevron {
    margin-left: auto;
    font-size: 0.9rem;
    opacity: 0.7;
    transition: transform 0.15s ease-out;
  }

  .theory-details[open] .theory-chevron {
    transform: rotate(180deg);
  }

  .theory-content {
    padding: 14px 18px 16px;
    font-size: 0.9rem;
    color: var(--text-muted);
  }

  .theory-content ul {
    margin: 10px 0 8px;
    padding-left: 20px;
  }

  .theory-content li {
    margin-bottom: 6px;
    line-height: 1.5;
  }


  /* Tarjetas específicamente de applet  */

  .card--applet::before {
    background: linear-gradient(to right, var(--accent-soft-strong), transparent);
    width: 100%;
    height: 4px;
  }

  .card--applet {
    padding-top: 20px;
  }

  /* -- Estilo ligero para SageCell (solo botón y salida) -- */

  .sagecell {
    margin-top: 10px;
  }

  .sagecell .sagecell_evalButton {
    position: relative;
    background: var(--accent);
    border-radius: 999px;
    border: none;
    padding: 6px 18px;
    font-size: 0.86rem;
    font-weight: 500;
    color: #ffffff;
    cursor: pointer;
    box-shadow: 0 8px 18px rgba(37,99,235,0.25);
    overflow: hidden;
    transition: transform 0.08s ease-out, box-shadow 0.08s ease-out,
                background 0.15s ease-out;
  }

  .sagecell .sagecell_evalButton::after {
    /* pequeño brillo diagonal animado */
    content: "";
    position: absolute;
    top: 0;
    left: -40%;
    width: 40%;
    height: 100%;
    background: linear-gradient(120deg, transparent, rgba(255,255,255,0.6), transparent);
    opacity: 0;
    transform: translateX(-100%);
    transition: opacity 0.2s ease-out, transform 0.4s ease-out;
  }

  .sagecell .sagecell_evalButton:hover {
    transform: translateY(-1px);
    box-shadow: 0 12px 26px rgba(37,99,235,0.35);
    background: #1d4ed8;
  }

  .sagecell .sagecell_evalButton:hover::after {
    opacity: 0.9;
    transform: translateX(220%);
  }

  .sagecell .sagecell_evalButton:active {
    transform: translateY(0);
    box-shadow: 0 4px 12px rgba(148,163,184,0.8);
  }

  .sagecell_output {
    margin-top: 10px;
    border-radius: 10px;
    border: 1px solid #e5e7eb;
    padding: 10px;
    background: #ffffff;
  }


  @media (max-width: 720px) {
    body {
      padding: 20px 12px 32px;
    }
    .card {
      padding: 14px 14px 10px;
    }
  }
  /* === Estilos para el Math-Canvas interactivo === */

  .math-canvas-wrapper {
    margin-top: 12px;
    display: flex;
    flex-direction: column;   /* controles arriba, canvas abajo */
    gap: 12px;
  }

  /* Controles */

  .math-canvas-controls {
    font-size: 0.9rem;
    color: var(--text-muted);
    padding: 12px 14px;
    border-radius: 12px;
    border: 1px solid #e5e7eb;
    background: #f8fafc;
  }

  .math-canvas-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 10px 18px;
    align-items: flex-end;
    margin-bottom: 8px;
  }

  .math-canvas-toolbar .group {
    display: flex;
    flex-direction: column;
    font-size: 0.85rem;
  }

  .math-canvas-toolbar label {
    margin-bottom: 2px;
  }

  .math-canvas-toolbar select {
    font-size: 0.85rem;
    padding: 4px 8px;
    border-radius: 999px;
    border: 1px solid #d1d5db;
    background: #ffffff;
  }

  /* Botones */

  .math-canvas-controls button {
    border: none;
    border-radius: 999px;
    padding: 6px 14px;
    margin-right: 6px;
    margin-bottom: 6px;
    font-size: 0.85rem;
    font-weight: 500;
    cursor: pointer;
    box-shadow: 0 8px 18px rgba(148,163,184,0.25);
    background: #ffffff;
    color: #111827;
    transition: transform 0.08s ease-out, box-shadow 0.08s ease-out,
                background 0.15s ease-out;
  }

  .math-canvas-controls button:hover {
    transform: translateY(-1px);
    box-shadow: 0 12px 26px rgba(148,163,184,0.35);
    background: var(--accent-soft, rgba(37,99,235,0.08));
  }

  .math-canvas-controls button.primary {
    background: var(--accent, #2563eb);
    color: #ffffff;
  }

  .math-canvas-controls button.primary:hover {
    background: #1d4ed8;
  }

  /* Panel de estado */

  .math-canvas-status {
    margin-top: 6px;
    padding: 8px 10px;
    border-radius: 10px;
    background: #f3f4ff;
    border: 1px solid rgba(129,140,248,0.4);
    font-size: 0.85rem;
    color: #374151;
  }

  .math-canvas-status b {
    color: #111827;
  }

  /* Caja del canvas */

  .math-canvas-canvasbox {
    background: #ffffff;
    border-radius: 12px;
    border: 1px solid #e5e7eb;
    padding: 10px;

    /* Altura fija para que no se rompa el layout */
    height: 440px;
    overflow: hidden;

    display: flex;
    justify-content: center;
    align-items: center;
  }

  /* El propio canvas */

  #math-canvas {
    width: 100%;
    height: 100%;
    max-width: 100%;
    border-radius: 12px;
    cursor: crosshair;

    background:
      radial-gradient(circle at top left, rgba(191,219,254,0.4) 0, transparent 55%),
      #f9fafb;
    border: 1px solid #e5e7eb;
    box-shadow: 0 14px 30px rgba(15,23,42,0.12);
  }

</style>

  </head>

  <body>
    <!-- contenedor principal -->
    <div class="page">

      <!-- BIBLIOTECA OCULTA: se auto-ejecuta y deja todo en memoria -->
      <div id="biblio" style="display:none;">
        <script type="text/x-sage">


############################################################
# BIBLIOTECA
############################################################

from random import gauss, uniform
from numpy.linalg import *

def dist(p,q):
    return sqrt((p[0]-q[0])**2 + (p[1]-q[1])**2)

# alias para la función distancia que usas luego
def distancia(p,q):
    return dist(p,q)

def puntoMedio(p,q):
    return [(p[0]+q[0])/2,(p[1]+q[1])/2]

def areaSignada(a,b,c):
    return ((b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0]))/2

def enSegmento(p,s):
    if areaSignada(p,s[0],s[1])!=0:
        return false
    return float(dist(p,s[0]))+float(dist(p,s[1]))==float(dist(s[0],s[1]))

def enSegmentoII(p,s):
    if areaSignada(p,s[0],s[1])!=0:
        return false
    if s[0][0]<=p[0] and p[0]<=s[1][0] or s[0][0]>=p[0] and p[0]>=s[1][0]:
        if s[0][1]<=p[1] and p[1]<=s[1][1] or s[0][1]>=p[1] and p[1]>=s[1][1]:
            return true
    return false

def enTriangulo(p,t):
    a1=areaSignada(t[0],t[1],p)
    a2=areaSignada(t[1],t[2],p)
    a3=areaSignada(t[2],t[0],p)
    if a1>=0 and a2>=0 and a3>=0 or a1<=0 and a2<=0 and a3<=0:
        return true
    else:
        return false

def testInterseccionSegmentos(p,q):
    if (areaSignada(p[0],p[1],q[0])*areaSignada(p[0],p[1],q[1])<0 and
        areaSignada(q[0],q[1],p[0])*areaSignada(q[0],q[1],p[1])<0):
        return true
    else:
        if enSegmento(p[0],q) or enSegmento(p[1],q) or enSegmento(q[0],p) or enSegmento(q[1],p):
            return true
        else:
            return false

def interseccionRectas(r,s):
    x1=r[1][1]-r[0][1]
    y1=r[0][0]-r[1][0]
    x2=s[1][1]-s[0][1]
    y2=s[0][0]-s[1][0]
    if x1*y2-x2*y1==0:
        print("\n* Rectas paralelas. ", end="")
    else:
        z1=r[0][0]*r[1][1]-r[0][1]*r[1][0]
        z2=s[0][0]*s[1][1]-s[0][1]*s[1][0]
        x=(z1*y2-z2*y1)/(x1*y2-x2*y1)
        y=(x1*z2-x2*z1)/(x1*y2-x2*y1)
        return [x,y]

def circuncentroI(a,b,c):
    r=[[(a[0]+b[0])/2,(a[1]+b[1])/2],
       [(a[0]+b[0])/2+(a[1]-b[1]),((a[1]+b[1])/2)+b[0]-a[0]]]
    s=[[(a[0]+c[0])/2,(a[1]+c[1])/2],
       [(a[0]+c[0])/2+(a[1]-c[1]),((a[1]+c[1])/2)+c[0]-a[0]]]
    return interseccionRectas(r,s)

def enCirculoI(a,b,c,d):
    cc=circuncentroI(a,b,c)
    if dist(cc,d)<=dist(cc,a):
        return true
    else:
        return false

def enCirculo(a,b,c,d):
    t=matrix([[1,1,1],[a[0],b[0],c[0]],[a[1],b[1],c[1]]])
    dt=det(t)
    if dt==0:
        print("alineados")
        return
    m=matrix([[1,1,1,1],
              [a[0],b[0],c[0],d[0]],
              [a[1],b[1],c[1],d[1]],
              [a[0]**2+a[1]**2,b[0]**2+b[1]**2,
               c[0]**2+c[1]**2,d[0]**2+d[1]**2]])
    dm=det(m)
    return dt*dm<=0

def mediatriz(a,b):
    if a == b:
        return
    ab = [b[0]-a[0],b[1]-a[1]]
    abo = [-ab[1],ab[0]]
    m = puntoMedio(a,b)
    return [m, [m[0]+abo[0],m[1]+abo[1]]]

def circuncentroII(a,b,c):
    r=mediatriz(a,b)
    s=mediatriz(b,c)
    return interseccionRectas(r,s)

def areaPoligono(p):
    area = 0
    for i in range(1,len(p)-1):
        area += areaSignada(p[0],p[i],p[i+1])
    return area

def puntosEnCirculo(c,P):
    cont = 0
    for i in P:
        if enCirculo(c[0],c[1],c[2],i):
            cont +=1
    return cont  

def testInterseccionRectaSegmento(r,s):
    if areaSignada(r[0],r[1],s[0])*areaSignada(r[0],r[1],s[1])>0:
        return false
    else:
        return true

def circuncentro(a,b,c):
    mx=2*(b[0]-a[0])
    my=-2*(a[1]-b[1])
    m=b[0]^2-a[0]^2+b[1]^2-a[1]^2
    nx=2*(c[0]-a[0])
    ny=-2*(a[1]-c[1])
    n=c[0]^2-a[0]^2+c[1]^2-a[1]^2
    if mx*ny-nx*my==0:
        print("puntos alineados")
        return 
    x=(m*ny-n*my)/(mx*ny-nx*my)
    y=(mx*n-nx*m)/(mx*ny-nx*my)
    return [x,y]

def en_circulo(a,b,c,d):
    med_bc = mediatriz(b,c)
    med_bd = mediatriz(b,d)
    centro = testInterseccionRectaSegmento(med_bc, med_bd)
    radio = distancia(centro, b)
    return distancia(centro, a) <= radio

def Xmax(p): 
    return max(p)
    
def Xmin(p):
    return min(p)

def Ymax(p):
    return max(p, key=lambda x:[x[1],x[0]])
    
def Ymin(p):
    return min(p, key=lambda x:[x[1],x[0]])

def Vmax(p,v):
    return max(p, key=lambda x:[x[0]*v[0]+x[1]*v[1], -x[0]*v[1]+x[1]*v[0]])
   
def Vmin(p,v):
    return min(p, key=lambda x:[x[0]*v[0]+x[1]*v[1], -x[0]*v[1]+x[1]*v[0]])

def pendienteMinima(p):
    return min(p, key=lambda x: [x[1]/x[0] if x[0]!= 0 else float("inf"),
                                 dist([0,0],x)])
     
def pendienteMaxima(p):
    return max(p, key=lambda x: [x[1]/x[0] if x[0]!= 0 else float("inf"),
                                 dist([0,0],x)])

def ordenX(p):
    return sorted(p)

def ordenY(p):
    return sorted(p, key=lambda x:[x[1],x[0]])

def ordenX_bubble(p):
    for i in range(len(p)):
        for j in range(i+1,len(p)):
            if p[j][0]<p[i][0]:
                p[i],p[j] = p[j],p[i]
    return p

def ordenV(p,v):
    return sorted(p, key=lambda x: [x[0]*v[0]+x[1]*v[1], -x[0]*v[1]+x[1]*v[0]])

def ordenAngular(p,C):
    derecha=[]
    izquierda=[]
    superior=[]
    inferior=[]
    for i in p:
        if i[0]>C[0]:
            derecha.append(i)
        elif i[0]<C[0]:
            izquierda.append(i)
        elif i[0]==C[0] and i[1]>C[1]:
            superior.append(i)
        elif i[0]==C[0] and i[1]<C[1]:
            inferior.append(i)
    derecha=sorted(derecha,key=lambda x:[(x[1]-C[1])/(x[0]-C[0]),dist(x,C)])
    izquierda=sorted(izquierda,key=lambda x:[(x[1]-C[1])/(x[0]-C[0]),dist(x,C)])
    superior=sorted(superior)
    inferior=sorted(inferior)
    if C in p:
        return [C]+derecha+superior+izquierda+inferior
    else:
        return derecha+superior+izquierda+inferior

def poligonizacionXmonotona(P):
    L = ordenX(P)
    pmin = Xmin(P)
    pmax = Xmax(P)
    Linf = []
    Lsup = []
    for punto in L:
        if areaSignada(pmin,pmax,punto) >= 0:
            Lsup.append(punto)
        else:
            Linf.append(punto)
    return Linf + list(reversed(Lsup))

def poligonizacionYmonotona(P):
    L = ordenY(P)
    pmin = Ymin(P)
    pmax = Ymax(P)
    Lizq = []
    Lder = []
    for punto in L:
        if areaSignada(pmin,pmax,punto) >= 0:
            Lizq.append(punto)
        else:
            Lder.append(punto)
    return Lder + list(reversed(Lizq))

def poligonizacionVmonotona(P,v):
    L = ordenV(P,v)
    pmin = Vmin(P,v)
    pmax = Vmax(P,v)
    Lizq = []
    Lder = []
    for punto in L:
        if areaSignada(pmin,pmax,punto) >= 0:
            Lizq.append(punto)
        else:
            Lder.append(punto)
    return Lder + list(reversed(Lizq))

def poligonizacionEstrellada(P):
    C = [(P[0][0]+P[1][0]+P[2][0])/3, (P[0][1]+P[1][1]+P[2][1])/3]
    return ordenAngular(P,C), C

############################################################
# GENERADORES
############################################################

class CloudGenerator:
    def __init__(self, size):
        self.cloud_method = None
        self.size = size
        
    def generate(self, cloud_method, **params):
        self.cloud_method = cloud_method
        if cloud_method == "gaussian":
            return self.gaussian(**params)
        else:
            self.cloud_method = "random"
            return self.random(**params)

    def gaussian(self, mean_x=0, std_x=1, coef_x=1,
                 mean_y=0, std_y=1, coef_y=1):
        return [
            (coef_x * gauss(mean_x, std_x),
             coef_y * gauss(mean_y, std_y))
            for _ in range(self.size)
        ]
        
    def random(self, coef_x=1, lowerb_x=0, upperb_x=1,
               coef_y=1, lowerb_y=0, upperb_y=1):
        return [
            (coef_x * uniform(lowerb_x, upperb_x),
             coef_y * uniform(lowerb_y, upperb_y))
            for _ in range(self.size)
        ]

class PolygonGenerator:
    def __init__(self):
        self.polygon_method = None

    def generate(self, how, points):
        if len(points) > 0:
            self.polygon_method = how
            if how == "x_monotona":
                return poligonizacionXmonotona(points)
            elif how == "y_monotona":
                return poligonizacionYmonotona(points)
            else:
                self.polygon_method = "estrellada"
                return poligonizacionEstrellada(points)[0]
        else:
            return []

############################################################
# CLOUD
############################################################

class PointCloud:
    def __init__(self, size=150, cloud_generator=None, polygon_generator=None):
        self.size = size
        self.points = []
        self.cloud_method = None
        self.cloud_generator = cloud_generator if cloud_generator else CloudGenerator(size)
        self.polygon_method = None
        self.polygon_generator = polygon_generator if polygon_generator else PolygonGenerator()
        self.polygon = None
    
    def generate_cloud(self, how="gaussian", **params):
        self.points = self.cloud_generator.generate(how, **params)
        self.cloud_method = self.cloud_generator.cloud_method
        
    def generate_polygon(self, how="estrellada"):
        self.polygon = self.polygon_generator.generate(how, self.points)
        self.polygon_method = self.polygon_generator.polygon_method
        return Polygon(self.polygon)
    
    def plot_cloud(self, **kwargs):
        return point(self.points, **kwargs)
    
    def convex_hull(self):
        return ConvexPolygon.from_points(self.points)

############################################################
# POLÍGONOS
############################################################
class Polygon:
    def __init__(self, points):
        self.points = list(points)
        
    def is_convex_point(self, idx):
        points = self.points
        vl = (idx-1) % len(points)
        vr = (idx+1) % len(points)
        return areaSignada(points[vl], points[idx], points[vr]) >= 0
    
    def is_convex(self):
        self.convex_steps = [] 
        for idx in range(len(self.points)):
            result = self.is_convex_point(idx)
            self.convex_steps.append({
                "idx": idx,
                "point": self.points[idx],
                "convex": result
            })

            if not result:
                return False

        return True
    
    def plot(self, polygon_color='blue', alpha=0.3,
             point_color='blue', size=10):
        polygon_data = {'color': polygon_color, 'alpha': alpha}
        points_data = {'color': point_color, 'size': size}
        return (point(self.points,
                      color=points_data["color"],
                      size=points_data["size"])
                + polygon(self.points,
                          color=polygon_data["color"],
                          alpha=polygon_data["alpha"]))

    def convex_hull(self):
        return ConvexPolygon.from_points(self.points)
    
    def point_in_polygon(self, q):
        P = self.points
        m = max(P)
        M = [m[0]+1,m[1]+0.001*random()]
        if q in P:
            sol = true
        else:
            cont=0
            for i in range(len(P)):
                if testInterseccionSegmentos([M,q],[P[i-1],P[i]]):
                    cont+=1
            if cont%2==0:
                sol=false
            else:
                sol=true
        return sol
    
    def area(self):
        p = self.points
        area = 0
        for i in range(1,len(p)-1):
            area += areaSignada(p[0],p[i],p[i+1])
        return area
    
    def get_diagonals(self):
        P = self.points
        n = len(P)
        internas = []
        externas = []

        if n < 4:
            # Un triángulo no tiene diagonales
            return internas, externas

        for i in range(n):
            for j in range(i + 1, n):
                
                if j == i + 1:
                    continue
                if i == 0 and j == n - 1:
                    continue

                p = P[i]
                q = P[j]

                es_diagonal = True
                for k in range(n):
                    a = P[k]
                    b = P[(k + 1) % n]

                    if k == i or (k + 1) % n == i or k == j or (k + 1) % n == j:
                        continue

                    if testInterseccionSegmentos([p, q], [a, b]):
                        es_diagonal = False
                        break

                if not es_diagonal:
                    continue
                    
                mid = puntoMedio(p, q)

                if self.point_in_polygon(mid):
                    internas.append((i, j))
                else:
                    externas.append((i, j))

        return internas, externas


class ConvexPolygon(Polygon):
    def __init__(self, points):
        super().__init__(points)

    @classmethod
    def from_points(cls, points):
        hull_points = cls.graham(points)
        return cls(hull_points)

    @staticmethod
    def graham(points):
        P = list(points)
        if len(P) < 3:
            return P

        O = Xmin(P)               
        Q = ordenAngular(P, O)      

        i = 1
        while i < len(Q) - 1:
            if areaSignada(Q[(i-1) % len(Q)], Q[i], Q[(i+1) % len(Q)]) < 0:
                Q.pop(i)
                if i > 0:
                    i -= 1
            else:
                i += 1
        return Q
    
    def point_in_convex(self, p):
        P = self.points
        n = len(P)
        if n < 3:
            return false
        ref = None
        
        for i in range(n):
            a = P[i]
            b = P[(i+1) % n]
            s = areaSignada(a, b, p)
            if s == 0:
                if enSegmento(p, [a, b]):
                    return true
                else:
                    continue
            if not ref:
                ref = s
            else:
                if s * ref < 0:
                    return false
        return true

    def is_tangent(self, p, i):
        v_prev = self.points[i-1]
        v      = self.points[i]
        v_next = self.points[(i+1) % len(self.points)]

        s1 = areaSignada(v_prev, v,     p)
        s2 = areaSignada(v,      v_next, p)

        left_on_1 = (s1 >= 0)
        left_on_2 = (s2 >= 0)

        return left_on_1 != left_on_2

    
    def get_tangents(self, p):
        if self.point_in_convex(p):
            return None

        tangents = []
        n = len(self.points)

        for i in range(n):
            if self.is_tangent(p, i):
                tangents.append(self.points[i])
                if len(tangents) == 2:
                    return tangents

        return None
    
    def get_convex_diagonals(self):
        n = len(self.points)
        internas = []
        externas = []  

        if n < 4:
            # Un triángulo no tiene diagonales
            return internas, externas

        for i in range(n):
            for j in range(i + 1, n):
                if j == i + 1:
                    continue
                if i == 0 and j == n - 1:
                    continue

                # En un polígono convexo cualquier par no adyacente es diagonal interna
                internas.append((i, j))

        return internas, externas


class PolygonHandler:
    def __init__(self, max_length=10):
        self.polygons = []
        self.max_length = max_length
        self.selected_index = None

    def add_polygon(self, polygon):
        if len(self.polygons) >= self.max_length:
            # quitamos el primero
            self.polygons.pop(0)

            # si había uno seleccionado, su índice se desplaza
            if self.selected_index is not None:
                self.selected_index -= 1
                if self.selected_index < 0 or self.selected_index >= len(self.polygons):
                    self.selected_index = None

        self.polygons.append(polygon)

    def get_next(self):
        if not self.polygons:
            return None
        p = self.polygons.pop(0)
        # reajustar selección si hace falta
        if self.selected_index is not None:
            if self.selected_index == 0:
                self.selected_index = None
            else:
                self.selected_index -= 1
        return p

    def peek(self):
        if not self.polygons:
            return None
        return self.polygons[0]

    def __len__(self):
        return len(self.polygons)
    
    def clean(self):
        self.polygons = []
        self.selected_index = None
        
    def select_polygon(self, idx):
        # idx es 1-based
        if 1 <= idx <= len(self.polygons):
            self.selected_index = idx - 1
            return self.polygons[self.selected_index]
        else:
            self.selected_index = None
            return None

    def get_selected(self):
        if self.selected_index is None:
            return None
        if 0 <= self.selected_index < len(self.polygons):
            return self.polygons[self.selected_index]
        # por si se ha desfasado el índice
        self.selected_index = None
        return None

handler = PolygonHandler()
selected_point = None
        </script>
      </div>

      <header>
        <div class="title">
          Estudio general punto-polígono
          <span class="title-badge">Nubes, convexidad y tangentes · SageMath</span>
        </div>
        <p class="subtitle">
          Interfaz interactiva para estudiar la posición de un punto respecto a un polígono:
          generación de nubes, cierre convexo, convexidad, prueba punto en polígono, tangentes y área.
        </p>

        <p class="byline">Alejandro Alcázar Mendoza · <span style="opacity:0.7;">202302063@alu.icai.comillas.edu</span></p>
        <p class="byline">Jorge Gonzélez Pérez · <span style="opacity:0.7;">202304501@alu.icai.comillas.edu</span></p>
        <p class="byline">Javier Andrés Bernardez · <span style="opacity:0.7;">202305100@alu.comillas.edu</span></p>
        <p class="byline">Geometría Computacional · <span style="opacity:0.7;">ICAI, iMAT</span></p>
      </header>

      <hr>

    <section class="intro-card">
      <h2>Introducción</h2>

      <p>
        Este proyecto constituye un entorno interactivo para el estudio sistemático de las relaciones entre
        un punto y un polígono generados a partir de un conjunto discreto de puntos en el plano. El objetivo
        es analizar, visualizar y comparar distintos algoritmos fundamentales de la geometría computacional,
        poniendo especial énfasis en su comportamiento geométrico y en su interpretación estructural.
      </p>

      <p>
        La herramienta combina una representación continua en <em>canvas</em> con applets interactivos específicos,
        permitiendo inspeccionar paso a paso las decisiones combinatorias y geométricas que toman los algoritmos.
        De este modo, constituye un apoyo tanto para la docencia de geometría computacional como para la exploración
        experimental de estructuras poligonales a partir de datos.
      </p>
    </section>

    <section>
      <div class="card theory-card">
        <details class="theory-details">
          <summary class="theory-summary">
            <span class="theory-icon">a</span>
            <span class="theory-title">Aplicaciones de la Geometría Computacional en general</span>
            <span class="theory-chevron">▾</span>
          </summary>

          <div class="theory-content">
              <section>
                <p>
                  La asignatura destaca que la Geometría Computacional aparece en informática gráfica y reconstrucción de modelos 3D, donde se necesitan algoritmos eficientes para manejar mallas y escenas complejas. También es fundamental en visión artificial y sistemas de información geográfica (SIG), para reconocer formas, analizar mapas y gestionar grandes bases de datos espaciales. Otros ámbitos señalados son la robótica (planificación y navegación), el diseño asistido por ordenador (CAD) y procesos de fabricación, así como áreas científicas como biología molecular y astrofísica, donde se estudian estructuras geométricas de datos experimentales.
                </p>
                <p>
                  <strong>Fuente:</strong>
                  <a href="https://medium.com/%40sakshishakhawar/applications-of-computational-geometry-algorithms-d0b808fdb3d5"
                    target="_blank" rel="noopener noreferrer">
                    Medium: Applications of Computational Geometry Algorithms
                  </a>
                </p>
              </section>
          </div>
        </details>
      </div>
    </section>



    <section>
      <h2>Instrucciones</h2>

      <p>
        En la primera sección encontrarás varios applets encadenados. El <strong>Applet&nbsp;1</strong>
        permite generar una nube de puntos y construir distintos polígonos; cada polígono creado se
        <strong>almacena en una cola con un máximo de 10 polígonos en memoria</strong>.
      </p>

      <p>
        En el <strong>Applet&nbsp;2</strong> se selecciona el <strong>polígono activo</strong> de esa cola,
        mientras que en el <strong>Applet&nbsp;4</strong> se elige el <strong>punto de consulta</strong>
        desde el que se aplican las distintas pruebas geométricas (interioridad, tangentes, etc.).
      </p>

      <p>
        La segunda sección ofrece un <strong>canvas interactivo</strong> donde es posible añadir puntos,
        cerrar el polígono mediante distintos métodos y visualizar de forma unificada los resultados de los
        algoritmos sin necesidad de usar SageMath.
      </p>
    </section>

      <hr>

      <section>

        <h2>Generador y Selector</h2>
<p>
  Esta sección reúne los dos applets fundamentales para iniciar el flujo de trabajo: la
  <b>generación</b> de polígonos a partir de una nube de puntos y la <b>selección</b> del polígono
  activo con el que operarán las herramientas posteriores. El Applet&nbsp;1 produce distintos tipos
  de poligonizaciones y las almacena en una cola de hasta diez elementos, mientras que el
  Applet&nbsp;2 permite escoger cualquiera de ellos para su visualización y análisis detallado.
</p>

      </section>

<section>
  <div class="card theory-card">
    <details class="theory-details">
      <summary class="theory-summary">
        <span class="theory-icon">i</span>
        <span class="theory-title">Generación de nubes de puntos</span>
        <span class="theory-chevron">▾</span>
      </summary>

      <div class="theory-content">

        <h4>Distribución uniforme (random)</h4>
        <p>
          En este modo, cada punto \( (x, y) \) se escoge de manera <b>uniforme</b> dentro de un
          rectángulo. Matemáticamente:
        </p>

        <p style="text-align:center; font-size:0.95rem;">
          \[
            x \sim U(a,b), \qquad
            y \sim U(c,d)
          \]
        </p>

        <p>
          Todas las posiciones tienen la misma probabilidad. La densidad de probabilidad es constante:
        </p>

        <p style="text-align:center; font-size:0.95rem;">
          \[
            f(x,y) = 
            \frac{1}{(b-a)(d-c)}
            \quad \text{para } x\in[a,b],\; y\in[c,d].
          \]
        </p>

        <p>
          La nube resultante tiende a distribuirse de manera homogénea por el plano.
        </p>


        <h4>Distribución gaussiana (normal)</h4>
        <p>
          En este modo, los puntos se generan siguiendo una <b>distribución normal bidimensional</b>
          centrada típicamente en el origen. Cada coordenada es independiente:
        </p>

        <p style="text-align:center; font-size:0.95rem;">
          \[
            x \sim \mathcal{N}(0, \sigma^2),
            \qquad
            y \sim \mathcal{N}(0, \sigma^2)
          \]
        </p>

        <p>
          Su densidad conjunta es:
        </p>

        <p style="text-align:center; font-size:0.95rem;">
          \[
            f(x,y)
            \;=\;
            \frac{1}{2\pi\sigma^{2}}
            \exp\!\left(
              -\frac{x^{2}+y^{2}}{2\sigma^{2}}
            \right).
          \]
        </p>

        <p>
          La concentración es mayor cerca del centro y decrece radialmente, produciendo nubes más compactas.
        </p>


        <h4>Comparación geométrica</h4>
        <ul>
          <li>
            <b>Uniforme:</b> dispersión regular, bordes menos predecibles, poligonizaciones más variadas.
          </li>
          <li>
            <b>Gaussiana:</b> mayor densidad central, polígonos más compactos y formas más suaves.
          </li>
        </ul>

        <p>
          Estas distribuciones permiten estudiar cómo la estructura de la nube inicial afecta a las
          poligonizaciones y a los algoritmos geométricos utilizados en la primera sección.
        </p>

      </div>
    </details>
  </div>
</section>

<section>
  <div class="card theory-card">
    <details class="theory-details">
      <summary class="theory-summary">
        <span class="theory-icon">i</span>
        <span class="theory-title">Poligonizaciones</span>
        <span class="theory-chevron">▾</span>
      </summary>

      <div class="theory-content">

        <h4>1. Envolvente convexa (Graham Scan)</h4>
        <p>
          Graham Scan construye el <b>cierre convexo</b> de una nube de puntos ordenando los puntos por
          ángulo polar y descartando aquellos que generan un giro no permitido.
          El criterio principal se basa en el <b>signo del área</b>:
        </p>

        <p style="text-align:center; font-size:0.95rem;">
          \[
            \Delta(p_{i-1}, p_i, p_{i+1}) \;>\; 0 
            \quad \Rightarrow \quad
            \text{giro antihorario (válido)}
          \]
        </p>

        <p>
          El resultado es un polígono convexo que contiene todos los puntos del conjunto.
        </p>


        <h4>2. Poligonización monótona en \(x\)</h4>
        <p>
          Un polígono es <b>monótono en \(x\)</b> si cualquier recta vertical interseca su interior en un
          único segmento. Para construir una poligonización de este tipo:
        </p>

        <ul>
          <li>se ordenan los puntos por su coordenada \(x\),</li>
          <li>se conectan formando dos cadenas (superior e inferior),</li>
          <li>garantizando que cada cadena es monótona respecto al eje \(x\).</li>
        </ul>

        <p>
          Esta estructura es fundamental en algoritmos de triangulación y en la descomposición en polígonos simples.
        </p>


        <h4>3. Poligonización monótona en \(y\)</h4>
        <p>
          Es análoga al caso anterior, pero respecto al eje vertical. Un polígono es
          <b>monótono en \(y\)</b> si cualquier recta horizontal lo corta en un único segmento.
        </p>

        <p>
          Se obtiene ordenando los puntos por \(y\) y formando cadenas superior e inferior monótonas.
        </p>


        <h4>4. Poligonización estrellada</h4>
        <p>
          Un polígono es <b>estrellado</b> si existe un punto \(c\) tal que todos los segmentos
          \(\overline{c\,v_i}\) hacia los vértices están completamente dentro del polígono.
        </p>

        <p style="text-align:center; font-size:0.95rem;">
          \[
            \forall i,\quad \overline{c\,v_i} \subset P
          \]
        </p>

        <p>
          En la poligonización estrellada generada por el applet, se selecciona un centro y se ordenan los vértices por ángulo circular alrededor de él, generando
          una poligonal sin autointersecciones.
        </p>

      </div>
    </details>
  </div>
</section>



      <!-- APPLET 1 -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 1 · Generador de polígonos</div>
            <span class="card-tag">Generador</span>
          </div>
      <div class="card-body">
        <p>
          Este applet genera una nube de puntos en el plano, eligiendo el número de puntos y el tipo de
          distribución (<b>gaussiana</b> o <b>aleatoria uniforme</b>). A partir de esa nube construye un
          polígono mediante el algoritmo seleccionado (<b>Graham</b>, poligonización <b>monótona</b> en
          <i>x</i> o <i>y</i>, o poligonización <b>estrellada</b>), que se muestra superpuesto a los datos.
        </p>
        <p>
          Cada vez que se ejecuta, el polígono obtenido se <b>guarda en la cola interna</b>, de donde podrá
          seleccionarse más adelante en el Applet&nbsp;2 para ser analizado por el resto de la sección.
        </p>

          <div class="compute-applet" id="applet1">
            <script type="text/x-sage">
current_pc  = None
current_P   = None
last_params = None

@interact(layout=dict(
    top=[
        ['n_puntos'],
        ['metodo', 'poligo', 'actualizar']
    ]
))
def applet_nube(
    n_puntos = slider(10, 500, 10, default=10,
                      label="N puntos"),
    metodo   = selector(["gaussian", "random"],
                        label="Método"),
    poligo   = selector(["Monótono y", "Monótono x", "Graham", "Estrellado"],
                        label="Poligonización"),
    actualizar = checkbox(True, label="Actualizar")
):
    global current_pc, current_P, last_params

    params = (int(n_puntos), str(metodo), str(poligo))

    # Siempre generamos la primera vez (current_pc is None),
    # después solo si "Actualizar" está marcado y cambian los parámetros.
    need_regen = (current_pc is None) or (actualizar and params != last_params)

    if need_regen:
        pc = PointCloud(size=n_puntos)
        pc.generate_cloud(metodo)

        if poligo == "Estrellado":
            P = pc.generate_polygon()
        elif poligo == "Monótono x":
            P = pc.generate_polygon("x_monotona")
        elif poligo == "Monótono y":
            P = pc.generate_polygon("y_monotona")
        else:   # Graham
            P = pc.convex_hull()

        current_pc  = pc
        current_P   = P
        last_params = params
        handler.add_polygon(P)
    else:
        pc = current_pc
        P  = current_P

    g  = point(pc.points, size=15, rgbcolor=(0.10, 0.20, 0.80))
    g += polygon(P.points, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
    show(g, aspect_ratio=1, axes=True, figsize=5)

            </script>
          </div>
        </div>
      </section>

      <!-- APPLET 2 SELECCIÓN DE POLÍGONO -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 2 · Selector de polígono</div>
            <span class="card-tag">Selector</span>
          </div>
            <div class="card-body">
              <p>
                Este applet permite <b>elegir el polígono activo</b> entre los que han sido generados y almacenados
                previamente en la cola del Applet&nbsp;1. Basta con seleccionar su índice para visualizarlo y
                marcarlo como el polígono sobre el que trabajarán los applets siguientes.
              </p>
              <p>
                Si el índice corresponde a una posición vacía de la cola, el applet mostrará un aviso indicando que
                no existe ningún polígono almacenado en ese lugar.
              </p>
            </div>

          <div class="compute-applet" id="applet2">
            <script type="text/x-sage">

s = f"Has guardado {len(handler)} polígono{"" if len(handler) == 1 else "s"}"
pretty_print(html(f"<h3 style='text-align:center;'>{s}</h3>"))
@interact
def applet_2(
    idx = slider(1, 10, 1, default=1,
                 label="Índice de polígono (1–10)")
):
    # seleccionar en el handler (1-based) y dejarlo marcado como seleccionado
    P = handler.select_polygon(idx)

    if P is None:
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "No hay polígono almacenado en esa posición."
            "</span>"
        ))
        return

    g = polygon(P.points, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
    g += point(P.points, size=15, rgbcolor=(0.10, 0.20, 0.80))
    g += line(P.points + [P.points[0]],
              rgbcolor=(0.10, 0.20, 0.60),
              thickness=1)
    show(g, aspect_ratio=1, axes=False, figsize=5)
            </script>
          </div>
        </div>
      </section>

      <!-- APPLET G1 · Guardar lista de puntos -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet G1 · Guardar lista de puntos</div>
            <span class="card-tag">Guardar</span>
          </div>
          <div class="card-body">
            <p>
              Muestra las coordenadas del polígono seleccionado (Applet 2) en una lista
              que puedes copiar al portapapeles.
            </p>
          </div>

          <!-- OJO: id distinto de applet2, y sin anidar compute-applet -->
          <div class="compute-applet" id="appletG1">
            <script type="text/x-sage">
P = handler.get_selected()

if P is None:
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "No hay ningún polígono seleccionado (usa el Applet 2)."
        "</h3>"
    ))
else:
    pretty_print(html(
        "<h3 style='text-align:center;'>Lista de puntos del polígono seleccionado</h3>"
    ))
    lista = "[\n"
    for (x, y) in P.points:
        lista += "  [%.4f, %.4f],\n" % (float(x), float(y))
    lista += "]"

    html_str = """
<div style='margin-top:10px;'>
  <textarea id="poly-coords" rows="10"
            style="width:100%%; font-family:monospace; font-size:0.85rem;">%s</textarea>
  <br>
  <button type="button"
          style="margin-top:6px; padding:4px 10px; border-radius:999px;
                 border:1px solid #d1d5db; background:#fff; cursor:pointer;
                 font-size:0.85rem;"
          onclick="var ta = document.getElementById('poly-coords');
                   ta.select();
                   document.execCommand('copy');">
    Copiar al portapapeles
  </button>
</div>
""" % lista

    pretty_print(html(html_str))
            </script>
          </div>
        </div>
      </section>



    <hr>
      <section>
        <h2>Convexidad</h2>
<p>
  Los applets de esta sección permiten visualizar de manera detallada cómo los conceptos
  teóricos de orientación, área signada y clasificación de vértices se traducen en
  procedimientos computacionales. El análisis paso a paso muestra no solo si un polígono es
  convexo o no, sino por qué lo es, identificando los vértices responsables de su geometría.
</p>

      </section>



    <section>
      <div class="card theory-card">
        <details class="theory-details">
          <summary class="theory-summary">
            <span class="theory-icon">i</span>
            <span class="theory-title">Área signada de un triángulo</span>
            <span class="theory-chevron">▾</span>
          </summary>

          <div class="theory-content">
            <p>
              Dados tres puntos 
              \( p_1 = (x_1, y_1),\; p_2 = (x_2, y_2),\; p_3 = (x_3, y_3) \),
              el área signada del triángulo que determinan se calcula mediante el siguiente determinante:
            </p>

            <p style="text-align:center; font-size:0.95rem;">
              \[
              \Delta(p_1, p_2, p_3)
              = \frac{1}{2}
              \det \begin{pmatrix}
              1 & 1 & 1 \\
              x_1 & x_2 & x_3 \\
              y_1 & y_2 & y_3
              \end{pmatrix}
              \]
            </p>

            <p>
              Esta expresión es equivalente a la usada en el código Sage de la presentación, basada en
              una diferencia de productos vectoriales en dos dimensiones, una forma más eficiente
              computacionalmente:
            </p>

            <p style="text-align:center; font-size:0.95rem;">
              \[
              \frac{
              (b_x - a_x)(c_y - a_y)
              \;-\;
              (b_y - a_y)(c_x - a_x)
              }{2}
              \]
            </p>

            <p>
              El signo del área indica la orientación del recorrido
              \( p_1 \to p_2 \to p_3 \): positiva si es antihorario y negativa si es horario.
            </p>
          </div>
        </details>
      </div>
    </section>

<section>
  <div class="card theory-card">
    <details class="theory-details">
      <summary class="theory-summary">
        <span class="theory-icon">i</span>
        <span class="theory-title">Convexidad de un polígono</span>
        <span class="theory-chevron">▾</span>
      </summary>

      <div class="theory-content">

        <h4>Definición matemática</h4>
        <p>
          Un polígono \(P\) es <b>convexo</b> si para cualquier par de puntos \(x, y \in P\),
          el segmento \( \overline{xy} \) está completamente contenido en el polígono:
        </p>

        <p style="text-align:center; font-size:0.95rem;">
          \[
            \overline{xy} \subset P.
          \]
        </p>

        <p>
          Si existe algún par de puntos cuyo segmento no queda dentro de \(P\), entonces
          el polígono es <b>no convexo</b> (o <b>cóncavo</b>).
        </p>

        <h4>Test computacional (basado en el área signada)</h4>

        <p>
          Para comprobar computacionalmente la convexidad, se clasifica cada vértice del polígono
          mediante el <b>test de orientación</b>, implementado con el área signada.
          Dado un vértice \(v_i\) y sus adyacentes \(v_{i-1}\) y \(v_{i+1}\), se evalúa:
        </p>

        <p style="text-align:center; font-size:0.95rem;">
          \[
            \Delta(v_{i-1}, v_i, v_{i+1})
          \]
        </p>

        <p>
          Suponiendo que el polígono está orientado en sentido <b>antihorario</b>, se clasifica:
        </p>

        <ul>
          <li>
            \( \Delta(v_{i-1}, v_i, v_{i+1}) \ge 0 \):  
            el vértice \(v_i\) es <b>convexo</b> (incluye colinealidad: \(\Delta = 0\)).
          </li>
          <li>
            \( \Delta(v_{i-1}, v_i, v_{i+1}) &lt; 0 \):  
            el vértice \(v_i\) es <b>cóncavo</b>.
          </li>
        </ul>

        <p>
          El polígono es <b>convexo</b> si y solo si <b>todos</b> sus vértices son convexos.
          Basta con encontrar un único vértice cóncavo para que el polígono sea no convexo.
        </p>

      </div>
    </details>
  </div>
</section>


      <!-- APPLET 3  -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 3 · Análisis de convexidad</div>
            <span class="card-tag">Geometría</span>
          </div>
          <div class="card-body">
            <div class="card-body">
              <p>
                Este applet realiza un <b>análisis de convexidad</b> sobre el polígono seleccionado en el
                Applet&nbsp;2. Para cada vértice se aplica el test de orientación basado en el
                <b>área signada</b>, determinando si se trata de un vértice convexo o cóncavo.
              </p>

              <p>
                El control deslizante permite recorrer los pasos del algoritmo y visualizar, para cada vértice,
                sus puntos adyacentes y el triángulo local utilizado en la clasificación. Los vértices convexos
                se muestran en <span style="color:green;"><b>verde</b></span> y los cóncavos en
                <span style="color:red;"><b>rojo</b></span>.
              </p>
            </div>

          </div>

          <div class="compute-applet" id="applet3">
            <script type="text/x-sage">


P = handler.get_selected()

if P is None:
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "No hay seleccionado ningún polígono"
        "</h3>"
    ))

    @interact
    def ver_pasos_convexidad():
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "Selecciona primero un polígono en el Applet 2."
            "</span>"
        ))

else:
    es_convexo = P.is_convex()
    s = "Convexo" if es_convexo else "No convexo"
    pretty_print(html(f"<h3 style='text-align:center;'>{s}</h3>"))

    n = len(P.points)
    pasos_pre = []
    for paso in P.convex_steps:
        idx = paso["idx"]
        pt = paso["point"]
        convex = paso["convex"]
        vl = (idx-1) % n
        vr = (idx+1) % n
        pt_left = P.points[vl]
        pt_right = P.points[vr]
        center_color = "green" if convex else "red"
        pasos_pre.append((idx, pt, pt_left, pt_right, center_color))

    @interact
    def ver_pasos_convexidad(
        k = slider(0, len(P.convex_steps)-1, 1, 0, label="Paso")
    ):
        idx, pt, pt_left, pt_right, center_color = pasos_pre[k]

        g  = polygon(P.points, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
        g += line(P.points + [P.points[0]],
                  rgbcolor=(0.10, 0.20, 0.60),
                  thickness=1)
        g += point(pt_left,  size=30, color='blue')
        g += point(pt_right, size=30, color='blue')
        g += point(pt, size=30, color=center_color)
        g += line([pt_left, pt, pt_right], color=center_color, thickness=1)

        show(g, aspect_ratio=1)


            </script>
          </div>
        </div>
      </section>

      <!-- APPLET  4 -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 4 · Análisis de Convexidad II </div>
            <span class="card-tag">Geometría</span>
          </div>
          <div class="card-body">
            <div class="card-body">
              <p>
                Este applet permite examinar la convexidad del polígono <b>vértice a vértice</b>, utilizando
                directamente el cálculo del <b>área signada</b> entre cada vértice y sus dos adyacentes. El
                proceso genera una secuencia de pasos que muestran la contribución individual de cada punto a
                la forma global del polígono.
              </p>

              <p>
                Mediante el deslizador se recorren todos los vértices: en cada paso se resalta el triángulo
                local asociado y se clasifica el vértice como
                <span style="color:green;"><b>convexo</b></span> o
                <span style="color:red;"><b>cóncavo</b></span>. En el paso final se visualiza la
                clasificación completa del polígono, permitiendo identificar de un vistazo su estructura
                geométrica.
              </p>
            </div>

          </div>

<div class="compute-applet" id="applet4">
  <script type="text/x-sage">
P = handler.get_selected()

# ========== DUMMY SI NO HAY POLÍGONO ==========
if P is None:
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "No hay seleccionado ningún polígono."
        "</h3>"
    ))

    @interact
    def applet_convexidad_dummy():
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "Selecciona primero un polígono en el Applet 2."
            "</span>"
        ))

else:
    pts = P.points
    n   = len(pts)

    if n < 3:
        pretty_print(html(
            "<h3 style='text-align:center;'>"
            "Un polígono debe tener al menos 3 vértices."
            "</h3>"
        ))

        @interact
        def applet_convexidad_dummy2():
            pretty_print(html(
                "<span style='font-size:0.9rem; color:#666;'>"
                "Selecciona un polígono válido."
                "</span>"
            ))

    else:
        # ----------------------------------------------------
        # PRECALCULO: lista de pasos
        # paso i: (i, v_prev, v, v_next, convex_bool)
        # ----------------------------------------------------
        steps = []

        for idx in range(n):
            v_prev = pts[(idx - 1) % n]
            v      = pts[idx]
            v_next = pts[(idx + 1) % n]

            s = areaSignada(v_prev, v, v_next)
            convex = (s >= 0)

            steps.append((idx, v_prev, v, v_next, convex))

        max_k = len(steps)

        pretty_print(html(
            "<h3 style='text-align:center;'>"
            "Análisis de convexidad vértice a vértice"
            "</h3>"
        ))

        @interact
        def applet_convexidad(
            k = slider(0, max_k, 1, default=0, label="Paso")
        ):
            # Dibujo base
            g  = polygon(pts, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
            g += line(pts + [pts[0]], rgbcolor=(0.10, 0.20, 0.60), thickness=1)

            # Caso k = 0 → solo polígono
            if k == 0:
                show(g, aspect_ratio=1, axes=True, figsize=5)
                pretty_print(html(
                    "<div style='text-align:center;'>"
                    "Ningún vértice inspeccionado todavía."
                    "</div>"
                ))
                return

            if k == max_k:
                for (idx, v_prev, v, v_next, convex) in steps:
                    color = "green" if convex else "red"
                    g += point([v], size=40, rgbcolor=color)

                show(g, aspect_ratio=1, axes=True, figsize=5)

                msg = (
                    "Paso final: vértices coloreados — "
                    "<span style='color:green;'><b>convexos</b></span> "
                    " / "
                    "<span style='color:red;'><b>cóncavos</b></span>."
                )
                pretty_print(html(
                    f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
                ))
                return

            # ----------------------------------------------------
            # Paso intermedio: analizar SOLO el vértice k-1
            # ----------------------------------------------------
            idx, v_prev, v, v_next, convex = steps[k-1]

            # triángulo local
            tri = [v_prev, v, v_next]
            col = "green" if convex else "orange"
            g += polygon(tri, alpha=0.35, color=col)
            g += line(tri + [tri[0]], color=col, thickness=2)

            # colorear vértices implicados
            g += point([v_prev], size=35, rgbcolor="blue")
            g += point([v_next], size=35, rgbcolor="blue")
            g += point([v], size=40, rgbcolor=("green" if convex else "red"))

            show(g, aspect_ratio=1, axes=True, figsize=5)

            msg = (
                f"Paso {k}: vértice {idx} → "
                + (
                    "<b style='color:green;'>CONVEXO</b>"
                    if convex
                    else "<b style='color:orange;'>CÓNCAVO</b>"
                )
            )
            pretty_print(html(
                f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
            ))
  </script>
</div>
      </section>

      <section>
        <div class="card theory-card">
          <details class="theory-details">
            <summary class="theory-summary">
              <span class="theory-icon">a</span>
              <span class="theory-title">Aplicaciones de la convexidad (cierres convexos)</span>
              <span class="theory-chevron">▾</span>
            </summary>

            <div class="theory-content">

                <section>
                  <p>
                    El cierre convexo se utiliza para reducir problemas sobre una nube de puntos a sus “puntos exteriores”, por ejemplo al calcular el diámetro: la máxima distancia siempre se alcanza entre vértices de la envolvente convexa, lo que permite diseñar algoritmos más rápidos que la fuerza bruta. Sobre polígonos convexos, la estructura convexa permite explotar técnicas de rotación de calibres para obtener no solo el diámetro, sino también la anchura mínima del conjunto y pares antipodales relacionados con bandas soporte. Estas ideas sirven como base para muchos problemas de optimización geométrica y de análisis de formas en dos dimensiones.
                  </p>
                  <p>
                    <strong>Fuente:</strong>
                    <a href="https://grokipedia.com/page/Rotating_calipers"
                      target="_blank" rel="noopener noreferrer">
                      Grokipedia: Rotating Clapiers
                    </a>
                  </p>
                </section>
            </div>
          </details>
        </div>
      </section>

    <hr>

      <section>

        <h2>Área</h2>
<p>
  En esta sección se calcula el área de un polígono mediante la descomposición en
  triángulos basada en el <b>área signada</b>. Este método permite obtener tanto el área
  total como la contribución de cada triángulo en una secuencia de pasos visuales.
</p>

      </section>

<section>
  <div class="card theory-card">
    <details class="theory-details">
      <summary class="theory-summary">
        <span class="theory-icon">i</span>
        <span class="theory-title">Área de un polígono</span>
        <span class="theory-chevron">▾</span>
      </summary>

      <div class="theory-content">

        <h4>Cálculo mediante áreas signadas</h4>
        <p>
          El área de un polígono \(P\) puede obtenerse sumando las
          <b>áreas signadas</b> de los triángulos formados por un punto arbitrario \(p\)
          (que puede estar dentro o fuera del polígono) y cada una de sus aristas.
        </p>

        <p style="text-align:center; font-size:0.95rem;">
          \[
            \text{Área}(P)
            \;=\;
            \sum_{i=0}^{n-1}
            \Delta\bigl(p,\; v_i,\; v_{i+1} \bigr),
            \qquad
            (v_n = v_0)
          \]
        </p>

        <p>
          Esta formulación es equivalente a la regla del "shoelace" y a los métodos
          clásicos de descomposición en triángulos, pero utilizando el área signada como
          unificador para la orientación.
        </p>

        <h4>Importancia del signo</h4>
        <p>
          El signo del área total no solo determina el valor geométrico, sino también
          la <b>orientación del polígono</b>:
        </p>

        <ul>
          <li><b>Área &gt; 0</b>: los vértices están en orientación
              <b>antihoraria </b>.</li>
          <li><b>Área &lt; 0</b>: los vértices están en orientación
              <b>horaria</b>.</li>
        </ul>

        <p>
          El valor absoluto del área proporciona el área geométrica real del polígono.
        </p>

      </div>
    </details>
  </div>
</section>


      <!-- APPLET 5  -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 5 · Área del polígono</div>
            <span class="card-tag">Geometría</span>
          </div>
          <div class="card-body">
            <p>
              Este applet calcula el <b>área del polígono</b> seleccionado en el
              Applet&nbsp;2 utilizando una triangulación fija respecto al primer vértice.
              Cada triángulo generado se evalúa mediante el <b>área signada</b>,
              acumulando sus contribuciones para obtener el área total.
            </p>

            <p>
              El deslizador permite avanzar paso a paso por la construcción: en cada etapa se
              resalta el triángulo correspondiente y se muestra la <b>acumulación parcial</b>
              del área. Al completar todos los pasos, se obtiene el valor final del área
              (mostrado en valor absoluto).
            </p>
          </div>
            <div class="compute-applet" id="applet5">
              <script type="text/x-sage">
P = handler.get_selected()

# ========== DUMMY: falta polígono ==========
if P is None:
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "No hay seleccionado ningún polígono."
        "</h3>"
    ))

    @interact
    def applet_area_dummy():
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "Selecciona primero un polígono en el Applet 2."
            "</span>"
        ))

else:
    # ----------------------------------------------------
    # PRECÁLCULO DE TRIÁNGULOS Y ÁREAS (fuera del interact)
    # ----------------------------------------------------
    pts = P.points
    n   = len(pts)

    if n < 3:
        pretty_print(html(
            "<h3 style='text-align:center;'>"
            "El polígono tiene menos de 3 puntos."
            "</h3>"
        ))

        @interact
        def applet_area_dummy2():
            pretty_print(html(
                "<span style='font-size:0.9rem; color:#666;'>"
                "Necesitas al menos un triángulo para calcular el área."
                "</span>"
            ))
    else:
        base = pts[0]
        step_data   = []   # (triángulo, área_signada, área_acumulada, color)
        acum = 0

        for i in range(1, n-1):
            a = pts[i]
            b = pts[i+1]
            s = areaSignada(base, a, b)      # área signada de este triángulo
            acum += s                       # acumulamos

            color = "green" if s >= 0 else "orange"
            tri   = [base, a, b]
            step_data.append((tri, s, acum, color))

        max_k       = len(step_data)
        area_final  = acum
        area_abs    = abs(acum)

        # Mensaje de resumen encima del applet
        pretty_print(html(
            f"<h3 style='text-align:center;'>"
            f"Área total = {area_abs:.4f}"
            f"</h3>"
        ))

        @interact
        def applet_area(
            k = slider(0, max_k, 1, default=0, label="Paso")
        ):
            # Dibujo base: polígono
            g  = polygon(pts, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
            g += line(pts + [pts[0]],
                      rgbcolor=(0.10, 0.20, 0.60),
                      thickness=1)

            # Añadimos, hasta el paso k, los triángulos
            area_parcial = 0
            for i in range(k):
                tri, s, acum_i, col = step_data[i]
                g += polygon(tri, alpha=0.35, color=col)
                g += line(tri + [tri[0]], color=col, thickness=1)
                area_parcial = acum_i

            show(g, aspect_ratio=1, axes=True, figsize=5)

            # Texto explicativo bajo la figura
            if k == 0:
                msg = (
                    "Sin triángulos aún: área parcial = 0.0000"
                )
            else:
                msg = (
                    f"Tras {k} triángulo(s): "
                    f"área signada parcial = <b>{area_parcial:.4f}</b>, "
                )

            pretty_print(html(
                f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
            ))

              </script>
            </div>
          </div>


      </section>

      <section>
        <div class="card theory-card">
          <details class="theory-details">
            <summary class="theory-summary">
              <span class="theory-icon">a</span>
              <span class="theory-title">Aplicaciones de área (área signada)</span>
              <span class="theory-chevron">▾</span>
            </summary>

            <div class="theory-content">

                <section>
                  <p>
                    El área signada de un triángulo se usa como predicado geométrico básico: permite localizar un punto respecto de una recta (saber si está a la izquierda, derecha o alineado con dos puntos dados) sin recurrir a trigonometría. También se emplea para comparar un ángulo con π y evitar funciones trigonométricas aproximadas. Otro uso importante es la clasificación de vértices de un polígono en convexos o cóncavos mediante el signo de Δ(v<sub>i−1</sub>, v<sub>i</sub>, v<sub>i+1</sub>). Finalmente, la suma de áreas signadas de triángulos permite calcular de forma sistemática el área de un polígono, tanto convexo como no convexo, a partir de sus vértices.
                  </p>
                  <p>
                    <strong>Fuente:</strong>
                    <a href="https://www.utdallas.edu/~daescu/convexhull.pdf"
                      target="_blank" rel="noopener noreferrer">
                      UTDALLAS: Orientations & Convex Hull Lecture
                    </a>
                  </p>
                </section>
            </div>
          </details>
        </div>
      </section>

      <hr>

      <section>
        <h2>Selección de punto</h2>
<p>
  En esta sección se define el <b>punto de consulta</b> que se utilizará en los algoritmos de
  posición relativa, tangentes y otras pruebas geométricas. El punto puede elegirse libremente
  mediante sus coordenadas, permitiendo explorar diferentes configuraciones respecto al polígono
  seleccionado.
</p>

      </section>

      <!-- APPLET 6  -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 6 · Selector de punto</div>
            <span class="card-tag">Selector</span>
          </div>
          <div class="card-body">
            <div class="card-body">
              <p>
                Este applet permite seleccionar de forma interactiva el <b>punto de consulta</b> mediante sus
                coordenadas \(x\) e \(y\). El punto elegido se representa en rojo sobre el polígono activo,
                permitiendo estudiar su posición relativa y utilizarlo posteriormente en los applets de
                interioridad, tangentes y pruebas geométricas asociadas.
              </p>

              <p>
                Las coordenadas pueden ajustarse con precisión mediante deslizadores, lo que facilita explorar
                distintos escenarios y analizar cómo varía la relación entre el punto y el polígono seleccionado
                en el Applet&nbsp;2.
              </p>
            </div>


          </div>

<div class="compute-applet" id="applet6">
  <script type="text/x-sage">
P = handler.get_selected()

if P is None:
    # Mensaje general
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "No hay seleccionado ningún polígono"
        "</h3>"
    ))

    # Interact “dummy” que solo muestra un recordatorio
    @interact
    def ver_pasos_convexidad():
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "Selecciona primero un polígono en el Applet 2."
            "</span>"
        ))
else:
  @interact
  def applet_4(
      x = slider(-3, 3, 0.01, default=-3, label="x"),
      y = slider(-3, 3, 0.01, default=-3, label="y")
  ):
      global selected_point

      # Redondeo (2 decimales)
      xr = round(float(x), 2)
      yr = round(float(y), 2)
      selected_point = (xr, yr)

      # Dibujo del polígono + punto seleccionado
      g  = polygon(P.points, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
      g += line(P.points + [P.points[0]],
                rgbcolor=(0.10, 0.20, 0.60),
                thickness=1)
      g += point([selected_point], size=30, rgbcolor='red')

      show(g, aspect_ratio=1, axes=True, figsize=5,
          xmin=-3, xmax=3, ymin=-3, ymax=3)

      # Texto bonito
      pretty_print(html(
          f"<div style='text-align:center; font-size:1.0rem;'>"
          f"Punto seleccionado: <b>({xr:.2f}, {yr:.2f})</b>"
          f"</div>"
      ))

  </script>
</div>
      </section>


      <hr>
      <section>
        <h2>Punto en Polígono</h2>
<p>
  En esta sección estudiamos la posición relativa de un punto respecto a un polígono.
  Distinguimos entre el caso <b>convexo</b> (donde basta analizar el signo de las áreas
  orientadas) y el caso <b>no convexo</b>, en el que utilizamos un algoritmo de
  <i>ray casting</i> para decidir si el punto queda en el interior o en el exterior.
</p>
      </section>


<div class="card theory-card">
  <details class="theory-details">
    <summary class="theory-summary">
      <span class="theory-icon">i</span>
      <span class="theory-title">Punto en polígono convexo</span>
      <span class="theory-chevron">▾</span>
    </summary>

    <div class="theory-content">

      <h4>Criterio del signo constante</h4>
      <p>
        En un <b>polígono convexo</b>, la posición de un punto \(p\) se determina
        comprobando el signo del área orientada
        \(\Delta(a,b,p)\) para cada arista consecutiva \([a,b]\).
      </p>

      <p style="text-align:center; font-size:0.95rem;">
        \[
          s_i
          = \Delta\bigl(v_i,\; v_{i+1},\; p\bigr)
          \qquad (i=0,\ldots,n-1)
        \]
      </p>

      <p>
        Si todos los valores \(s_i\) tienen el <b>mismo signo</b> (o si alguno
        es cero porque el punto está justo sobre un lado), entonces el punto se
        encuentra en el <b>interior</b> del polígono convexo.  
        En cuanto aparece un <b>cambio de signo</b>, el punto queda clasificado
        como <b>exterior</b>.
      </p>
    </div>
  </details>
</div>

<div class="card theory-card">
  <details class="theory-details">
    <summary class="theory-summary">
      <span class="theory-icon">i</span>
      <span class="theory-title">Punto en polígono no convexo</span>
      <span class="theory-chevron">▾</span>
    </summary>

    <div class="theory-content">

      <h4>Método del ray casting</h4>
      <p>
        Para determinar si un punto \(p\) pertenece al <b>interior</b> de un
        polígono no convexo, se utiliza el algoritmo de
        <i>ray casting</i>.  
        Consiste en trazar un rayo desde un punto exterior \(M\) hasta \(p\) y
        contar cuántas veces intersecta con los lados del polígono.
      </p>

      <p style="text-align:center; font-size:0.95rem;">
        \[
          \text{intersecciones} =
          \#\bigl([M,p] \cap [v_i,v_{i+1}]\bigr)
        \]
      </p>

      <p>
        Si el número de intersecciones es <b>impar</b>, el punto está en el
        <b>interior</b>.  
        Si es <b>par</b>, el punto está en el <b>exterior</b>.
      </p>

      <h4>Ventaja del método</h4>
      <p>
        Este procedimiento permite trabajar con polígonos <b>no convexos</b>,
        con <b>entrantes</b>, y en general con cualquier polígono simple.
      </p>

    </div>
  </details>
</div>

      <!-- APPLET 7  -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 7 · Punto en polígono</div>
            <span class="card-tag">Geometría</span>
          </div>
          <div class="card-body">
<p>
  Elige primero un polígono en el <b>Applet 2</b> y un punto en el <b>Applet 4</b>.
  Este applet aplica automáticamente el algoritmo adecuado:
  si el polígono es convexo, recorre sus lados comprobando el signo del área orientada;
  si no lo es, ejecuta un método de <i>ray casting</i> contando intersecciones con un rayo.
  Con el deslizador puedes seguir el proceso paso a paso y ver cómo se decide si el punto
  es <b>interior</b> o <b>exterior</b>.
</p>

          </div>

<div class="compute-applet" id="applet7">
  <script type="text/x-sage">

P = handler.get_selected()

# intentar recuperar el punto seleccionado
try:
    q = selected_point
except NameError:
    q = None

# ========== DUMMY: falta polígono o falta punto ==========
if P is None or q is None:
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "Selecciona un polígono (Applet 2) y un punto (Applet 4)."
        "</h3>"
    ))

    @interact
    def applet_punto_en_poligono_dummy():
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "No hay datos suficientes para ejecutar el algoritmo."
            "</span>"
        ))
else:
    es_convexo = P.is_convex()
    n = len(P.points)
    res = P.point_in_polygon(q)

    texto_res = "INTERIOR" if res else "EXTERIOR"

    pretty_print(html(
        "<h3 style='text-align:center;'>"
        + ("Polígono convexo" if es_convexo else "Polígono no convexo")
        + " · Resultado final: " + texto_res +
        "</h3>"
    ))
    
    if es_convexo:
        tri_data = []              
        ref = None
        sign_changed = False

        for i in range(n):
            a = P.points[i]
            b = P.points[(i+1) % n]
            s = areaSignada(a, b, q)

            if s == 0:
                color = "green"
                tri = [a, b, q]
                interior_hasta_aqui = not sign_changed
                tri_data.append((tri, color, interior_hasta_aqui))
                continue

            if ref is None:
                ref = s
            else:
                if ref * s < 0:
                    sign_changed = True

            color = "green" if s >= 0 else "orange"
            tri  = [a, b, q]
            interior_hasta_aqui = not sign_changed
            tri_data.append((tri, color, interior_hasta_aqui))

            if sign_changed:
                break

        max_k = len(tri_data)
    else:
        max_k = n

    @interact
    def applet_punto_en_poligono(
        k = slider(0, max_k, 1, default=0, label="Paso")
    ):
        g  = polygon(P.points, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
        g += line(P.points + [P.points[0]],
                  rgbcolor=(0.10, 0.20, 0.60),
                  thickness=1)
        g += point([q], size=30, rgbcolor='red')

        if es_convexo:
            # ------- CASO CONVEXO -------
            for i in range(k):
                tri, col, interior_hasta_aqui = tri_data[i]
                g += polygon(tri, alpha=0.35, color=col)
                g += line([q, tri[0]], color=col, thickness=1)
                g += line([q, tri[1]], color=col, thickness=1)

            show(g, aspect_ratio=1, axes=True, figsize=5)

            if k == 0:
                dentro = True   # al inicio lo consideramos interior
            else:
                dentro = tri_data[k-1][2]

            msg = "Tras {} paso(s) el punto es <b>{}</b> respecto al polígono.".format(
                k,
                "INTERIOR" if dentro else "EXTERIOR"
            )
            pretty_print(html(
                f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
            ))

        else:
            # ------- CASO NO CONVEXO (ray casting) -------
            Ppts = P.points
            m = max(Ppts)
            M = [m[0] + 1, m[1] + 0.001]
            g += point(m, color="blue")
            g += point(M, color="blue")
            g += line([m, M], linestyle="--")

            g += line([M, q], color='black', linestyle="--", thickness=1)

            cont = 0
            for i in range(k):
                a = Ppts[i-1]
                b = Ppts[i]
                if testInterseccionSegmentos([M, q], [a, b]):
                    cont += 1
                    g += line([a, b], color='orange', thickness=2)
                else:
                    g += line([a, b], color='green', thickness=2)

            show(g, aspect_ratio=1, axes=True, figsize=5)

            dentro = (cont % 2 == 1)
            msg = (
                f"Ray casting con los primeros {k} lados: "
                f"<b>{cont}</b> intersecciones. "
            )
            msg += "El punto es <b>INTERIOR</b>." if dentro else "El punto es <b>EXTERIOR</b>."
            pretty_print(html(
                f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
            ))


  </script>
</div>
      </section>

      <section>
        <div class="card theory-card">
          <details class="theory-details">
            <summary class="theory-summary">
              <span class="theory-icon">a</span>
              <span class="theory-title">Aplicaciones de punto en polígono</span>
              <span class="theory-chevron">▾</span>
            </summary>

            <div class="theory-content">

                <section>
                  <p>
                    Los algoritmos de localización de un punto en un polígono se aplican en SIG para saber a qué zona pertenece una ubicación, en gráficos por ordenador para pruebas de “picking” o selección, y en robótica o planificación para decidir si una posición está dentro de un obstáculo poligonal o en una zona libre. También son la base para estructuras de búsqueda espacial más complejas, como mapas trapezoidales o subdivisiones jerárquicas.
                  </p>
                  <p>
                    <strong>Fuente:</strong>
                    <a href="https://www.geeksforgeeks.org/c/point-in-polygon-in-c/"
                      target="_blank" rel="noopener noreferrer">
                      GeeksForGeeks: Point in Polygon in C
                    </a>
                  </p>
                </section>
            </div>
          </details>
        </div>
      </section>
      
<hr>

      <section>
        <h2>Rectas tangentes al polígono convexo</h2>
<p>
  En esta sección estudiamos las <b>rectas tangentes</b> desde un punto \(q\) exterior
  a un polígono. Si el polígono no es convexo, primero trabajamos con su
  <b>cierre convexo</b> para obtener las dos tangentes exteriores.
</p>

      </section>

      <section>  
  <div class="card theory-card">
    <details class="theory-details">
      <summary class="theory-summary">
        <span class="theory-icon">i</span>
        <span class="theory-title">Criterio de tangencia en el cierre convexo</span>
        <span class="theory-chevron">▾</span>
      </summary>

      <div class="theory-content">

        <h4>Vértice candidato y prueba local</h4>
        <p>
          Para un polígono convexo \(P\) y un punto exterior \(q\), cada vértice
          \(v_i\) se analiza junto con sus vecinos \(v_{i-1}\) y \(v_{i+1}\).
        </p>

        <p style="text-align:center; font-size:0.95rem;">
          <b>
            \(q - v_i\) es tangente a \(P\) si:
          </b><br>
          \(q\) está a la izquierda o sobre \((v_{i-1}, v_i)\)
          <b style="color:#b91c1c;">xor</b>
          \(q\) está a la izquierda o sobre \((v_i, v_{i+1})\).
        </p>

        <h4>Traducción con áreas orientadas</h4>
        <p>
          La condición “estar a la izquierda o sobre” se formula mediante el
          <b>signo del área orientada</b>:
        </p>

        <p style="text-align:center; font-size:0.95rem;">
          \[
            s_1 = \Delta(v_{i-1}, v_i, q), \qquad
            s_2 = \Delta(v_i, v_{i+1}, q).
          \]
        </p>

        <p>
          El vértice \(v_i\) define una tangente si exactamente una de las dos
          condiciones \(s_1 \ge 0\) o \(s_2 \ge 0\) se cumple, esto es,
          si los valores lógicos difieren (<b>xor</b>).  
          En ese caso, el segmento \(qv_i\) toca al polígono en \(v_i\)
          y no lo atraviesa, produciendo una de las dos tangentes exteriores.
        </p>

      </div>
    </details>
  </div>
</section>

      <!-- APPLET 8  -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 8 · Tangentes</div>
            <span class="card-tag">Geometría</span>
          </div>
          <div class="card-body">
<p>
  Selecciona un polígono en el <b>Applet 2</b> y un punto en el <b>Applet 4</b>.
  Este applet comprueba primero si el punto está dentro del cierre convexo:
  en ese caso no existen tangentes exteriores.  
  Si el punto es exterior, recorre los vértices del cierre convexo y detecta
  aquellos en los que el segmento <code>q–v<sub>i</sub></code> es <b>tangente</b>
  al polígono. Con el deslizador puedes seguir el proceso vértice a vértice
  y visualizar las tangentes encontradas.
</p>

        </div>
<div class="compute-applet" id="applet8">
  <script type="text/x-sage">

P = handler.get_selected()

try:
    q = selected_point
except NameError:
    q = None

# ========== DUMMY: falta polígono o falta punto ==========
if P is None or q is None:
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "Selecciona un polígono (Applet 2) y un punto (Applet 4)."
        "</h3>"
    ))

    @interact
    def applet_tangentes_dummy():
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "No hay datos suficientes para ejecutar el algoritmo de tangentes."
            "</span>"
        ))

else:
    es_convexo = P.is_convex()

    if es_convexo:
        CP = ConvexPolygon(P.points)
        aviso_convexidad = ""
    else:
        CP = P.convex_hull()
        aviso_convexidad = (
            "El polígono NO es convexo. "
            "Para calcular tangentes, usamos su cierre convexo (contorno oscuro)."
        )

    hull_pts = CP.points
    n = len(hull_pts)

    if n < 2:
        pretty_print(html(
            "<h3 style='text-align:center;'>"
            "El cierre convexo tiene menos de 2 puntos: no se pueden definir tangentes."
            "</h3>"
        ))

        @interact
        def applet_tangentes_dummy2():
            pretty_print(html(
                "<span style='font-size:0.9rem; color:#666;'>"
                "Selecciona un polígono con al menos 2 vértices en el cierre convexo."
                "</span>"
            ))

    else:
        # caja para fijar la ventana de dibujo
        xs = [p[0] for p in P.points] + [q[0]]
        ys = [p[1] for p in P.points] + [q[1]]
        xmin = min(xs) - 1
        xmax = max(xs) + 1
        ymin = min(ys) - 1
        ymax = max(ys) + 1

        # Si el punto es interior al cierre convexo, no hay tangentes reales desde fuera
        if CP.point_in_convex(q):
            pretty_print(html(
                "<h3 style='text-align:center;'>"
                "El punto está en el INTERIOR del cierre convexo: no hay tangentes exteriores."
                "</h3>"
            ))

            @interact
            def applet_tangentes_interior():
                g  = polygon(P.points, alpha=0.25, rgbcolor=(0.70, 0.80, 1.00))
                g += line(P.points + [P.points[0]],
                          rgbcolor=(0.30, 0.40, 0.90),
                          thickness=1)
                g += polygon(hull_pts, alpha=0.10, rgbcolor=(0.20, 0.30, 0.70))
                g += line(hull_pts + [hull_pts[0]],
                          rgbcolor=(0.10, 0.20, 0.60),
                          thickness=1)
                g += point([q], size=35, rgbcolor='red')

                show(g, aspect_ratio=1, axes=True, figsize=5,
                     xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)

                pretty_print(html(
                    "<div style='text-align:center; font-size:0.95rem;'>"
                    "El punto es interior: todas las rectas que lo unen con vértices cortan el interior del polígono."
                    "</div>"
                ))

        else:
            # ----------------------------------------------------
            # PRECÁLCULO DE PASOS:
            # ----------------------------------------------------
            steps = []              
            tangents_info = []     
            visited = set()

            for i in range(n):
                v_prev = hull_pts[i-1]
                v      = hull_pts[i]
                v_next = hull_pts[(i+1) % n]

                s1 = areaSignada(v_prev, v,     q)
                s2 = areaSignada(v,      v_next, q)

                left_on_1 = (s1 >= 0)
                left_on_2 = (s2 >= 0)
                es_tan_local = (left_on_1 != left_on_2)


                steps.append({
                    "type": "analysis",
                    "v_prev": v_prev,
                    "v": v,
                    "v_next": v_next,
                    "s1": s1,
                    "s2": s2,
                    "is_tangent": es_tan_local,
                    "index": i
                })
                analysis_step_index = len(steps) - 1

                if es_tan_local and tuple(v) not in visited:
                    visited.add(tuple(v))

                    qx, qy = float(q[0]), float(q[1])
                    vx, vy = float(v[0]), float(v[1])
                    dx, dy = vx - qx, vy - qy

                    factor = 0.6
                    ext = (vx + factor*dx, vy + factor*dy)

                    steps.append({
                        "type": "tangent",
                        "v": v,
                        "ext": ext,
                        "index": i,
                        "analysis_step": analysis_step_index
                    })

                    tangents_info.append({
                        "v": v,
                        "ext": ext,
                        "analysis_step": analysis_step_index
                    })

                    if len(tangents_info) == 2:
                        break

            max_k = len(steps)

            # Mensaje de cabecera
            pretty_print(html(
                f"<h3 style='text-align:center;'>{aviso_convexidad}</h3>"
            ))

            @interact
            def applet_tangentes(
                k = slider(0, max_k, 1, default=0, label="Paso")
            ):
                # Dibujo base: polígono original + cierre convexo + punto
                g  = polygon(P.points, alpha=0.25, rgbcolor=(0.70, 0.80, 1.00))
                g += line(P.points + [P.points[0]],
                          rgbcolor=(0.30, 0.40, 0.90),
                          thickness=1)
                g += polygon(hull_pts, alpha=0.10, rgbcolor=(0.20, 0.30, 0.70))
                g += line(hull_pts + [hull_pts[0]],
                          rgbcolor=(0.10, 0.20, 0.60),
                          thickness=1)
                g += point([q], size=35, rgbcolor='red')

                if k == 0:
                    show(g, aspect_ratio=1, axes=True, figsize=5,
                         xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)
                    pretty_print(html(
                        "<div style='text-align:center;'>"
                        "Ningún vértice inspeccionado todavía."
                        "</div>"
                    ))
                    return

                step = steps[k-1]


                if step["type"] == "analysis":
                    v_prev = step["v_prev"]
                    v      = step["v"]
                    v_next = step["v_next"]
                    s1     = step["s1"]
                    s2     = step["s2"]
                    es_tan_local = step["is_tangent"]

                    # triángulo 1: q, v_prev, v
                    tri1 = [q, v_prev, v]
                    col1 = "green" if s1 >= 0 else "orange"
                    g += polygon(tri1, alpha=0.35, color=col1)
                    g += line(tri1 + [tri1[0]], color=col1, thickness=1)

                    # triángulo 2: q, v, v_next
                    tri2 = [q, v, v_next]
                    col2 = "green" if s2 >= 0 else "orange"
                    g += polygon(tri2, alpha=0.35, color=col2)
                    g += line(tri2 + [tri2[0]], color=col2, thickness=1)

                    # vértice actual
                    g += point([v], size=40,
                               rgbcolor=("magenta" if es_tan_local else "blue"))

                    # tangentes ya encontradas en pasos anteriores
                    for t in tangents_info:
                        if t["analysis_step"] < step["index"]:
                            g += point([t["v"]], size=45, rgbcolor=(0.80, 0.00, 0.80))
                            g += line([q, t["ext"]],
                                      rgbcolor=(0.80, 0.00, 0.80),
                                      thickness=2)

                    show(g, aspect_ratio=1, axes=True, figsize=5,
                         xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)

                    msg = (
                        f"Paso {k}: inspeccionando vértice {step['index']} – "
                        f"{'<b>TANGENTE DETECTADA</b>' if es_tan_local else 'no es tangente'}"
                    )
                    pretty_print(html(
                        f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
                    ))
                else:
                    v   = step["v"]
                    ext = step["ext"]

                    # tangentes anteriores a este paso
                    for t in tangents_info:
                        if t["analysis_step"] < step["analysis_step"]:
                            g += point([t["v"]], size=45, rgbcolor=(0.80, 0.00, 0.80))
                            g += line([q, t["ext"]],
                                      rgbcolor=(0.80, 0.00, 0.80),
                                      thickness=2)

                    # tangente actual
                    g += point([v], size=50, rgbcolor=(0.90, 0, 0.90))
                    g += line([q, ext],
                              rgbcolor=(0.90, 0, 0.90),
                              thickness=2)

                    show(g, aspect_ratio=1, axes=True, figsize=5,
                         xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)

                    msg = (
                        f"Paso {k}: recta tangente mostrada en vértice {step['index']}."
                    )
                    pretty_print(html(
                        f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
                    ))


  </script>
</div>
      </section>

      <section>
        <div class="card theory-card">
          <details class="theory-details">
            <summary class="theory-summary">
              <span class="theory-icon">a</span>
              <span class="theory-title">Aplicaciones de tangentes de un polígono</span>
              <span class="theory-chevron">▾</span>
            </summary>

            <div class="theory-content">

                <section>
                  <p>
                    Las tangentes punto-polígono aparecen en problemas de visibilidad y planificación de trayectorias, por ejemplo para rodear un obstáculo poligonal siguiendo caminos más cortos. También son útiles en detección de colisiones y en el cálculo de rectas soporte de cuerpos convexos, paso previo a muchos algoritmos de optimización geométrica. En contextos más avanzados, las tangentes se usan para construir tangentes comunes entre polígonos convexos, fundamentales en problemas de envolventes y de separación de conjuntos.
                  </p>
                  <p>
                    <strong>Fuente:</strong>
                    <a href="https://www.sciencedirect.com/science/article/abs/pii/0020019088900221"
                      target="_blank" rel="noopener noreferrer">
                      ScienceDirect: Algorithms For Shortest Paths Between Convex Polygons
                    </a>
                  </p>
                </section>
            </div>
          </details>
        </div>
      </section>


<hr>

      <section>
        <h2>Diagonales de un polígono</h2>
<p>
<section>
  <p>
    Dada una poligonal simple \(P\) con vértices \(v_0, v_1, \dots, v_{n-1}\) en orden,
    llamamos <b>diagonal</b> a cualquier segmento que une dos vértices no consecutivos
    y que no coincide con el lado que cierra el polígono.  
    En un polígono <b>convexo</b> todas las diagonales son interiores, mientras que
    en un polígono <b>cóncavo</b> pueden aparecer diagonales que salen total o
    parcialmente al exterior.
  </p>
</section>

</p>

      </section>

      <section>  
  <div class="card theory-card">
    <details class="theory-details">
      <summary class="theory-summary">
        <span class="theory-icon">i</span>
        <span class="theory-title">Criterio de diagonalización</span>
        <span class="theory-chevron">▾</span>
      </summary>

<div class="theory-content">
        
  <h4>Segmento candidato</h4>
  <p>
    Sea \(P\) un polígono simple con vértices \(v_0, \dots, v_{n-1}\) en orden.
    Un par de índices \((i,j)\) con \(i &lt; j\) genera un <b>segmento candidato</b>
    \([v_i, v_j]\) si:
  </p>

  <ul>
    <li>\(j \ne i+1\) (no son vértices consecutivos),</li>
    <li>\((i,j) \ne (0,n-1)\) (no es el lado que cierra el polígono).</li>
  </ul>

  <p>
    Para cada segmento candidato comprobaremos primero si es realmente una
    <b>diagonal</b> (no corta al polígono), y en ese caso decidiremos si es
    <b>interna</b> o <b>externa</b>.
  </p>

  <h4>Paso 1 · ¿Es una diagonal?</h4>
  <p>
    El segmento \([v_i, v_j]\) es una diagonal válida de \(P\) si no corta a
    ninguna arista del polígono distinta de las que comparten extremos con
    \(v_i\) o \(v_j\).  
    Operativamente:
  </p>

  <p style="text-align:center; font-size:0.95rem;">
    \[
      [v_i, v_j] \text{ es diagonal} \quad \Longleftrightarrow \quad
      [v_i, v_j] \text{ no intersecta } [v_k, v_{k+1}]
      \text{ para ningún } k
    \]
  </p>

  <p>
    En el código esto se implementa con la función
    <code>testInterseccionSegmentos</code>: si detecta una intersección con
    alguna arista “no adyacente”, descartamos el segmento como diagonal.
  </p>

  <h4>Paso 2 · Diagonal interna vs externa</h4>
  <p>
    Una vez sabemos que \([v_i, v_j]\) es una diagonal, basta mirar un punto
    interior del segmento, por ejemplo su <b>punto medio</b>:
  </p>

  <p style="text-align:center; font-size:0.95rem;">
    \[
      m = \frac{v_i + v_j}{2}.
    \]
  </p>

  <p>
    Usamos el algoritmo de <b>punto en polígono</b>:
  </p>

  <ul>
    <li>Si <code>point_in_polygon(m)</code> es verdadera, la diagonal es <b>interna</b>.</li>
    <li>Si <code>point_in_polygon(m)</code> es falsa, la diagonal es <b>externa</b>.</li>
  </ul>

  <p>
    En un polígono convexo todos los segmentos candidatos que no son lados son
    diagonales <b>internas</b>. En un polígono cóncavo, en cambio, el algoritmo
    distingue entre diagonales internas (verde) y externas (naranja).
  </p>

</div>

    </details>
  </div>
</section>

      <!-- APPLET 9  -->
      <section>
        <div class="card">
          <div class="card-header">
            <div class="card-title">Applet 9 · Diagonales</div>
            <span class="card-tag">Geometría</span>
          </div>
          <div class="card-body">
<p>
<p>
  Selecciona un polígono en el <b>Applet 2</b>. Este applet muestra todas sus
  diagonales, explicando paso a paso cómo se determinan.
</p>

<p>
  Si el polígono es <b>convexo</b>, se dibujan sus diagonales internas en verde,
  en el orden en que el algoritmo recorre los vértices.
</p>

<p>
  Si es <b>cóncavo</b>, cada diagonal se analiza en tres pasos:
</p>

<ul>
  <li>Propuesta de la diagonal (gris),</li>
  <li>Punto medio (<span style="color:red;"><b>rojo</b></span>),</li>
  <li>Clasificación final: <span style="color:green;"><b>verde</b></span> si es interna,
     <span style="color:orange;"><b>naranja</b></span> si es externa.</li>
</ul>

<p>
  El deslizador permite visualizar el proceso completo, igual que en el Applet 8.
</p>

</p>

        </div>
<div class="compute-applet" id="applet9">
  <script type="text/x-sage">

P = handler.get_selected()
# ========== DUMMY: falta polígono ==========
if P is None:
    pretty_print(html(
        "<h3 style='text-align:center;'>"
        "No hay seleccionado ningún polígono."
        "</h3>"
    ))

    @interact
    def applet_diagonales_dummy():
        pretty_print(html(
            "<span style='font-size:0.9rem; color:#666;'>"
            "Selecciona primero un polígono en el Applet 2."
            "</span>"
        ))

else:
    pts = P.points
    n   = len(pts)

    # ========== Polígono demasiado pequeño ==========
    if n < 3:
        pretty_print(html(
            "<h3 style='text-align:center;'>"
            "El polígono tiene menos de 3 puntos."
            "</h3>"
        ))

        @interact
        def applet_diagonales_dummy2():
            pretty_print(html(
                "<span style='font-size:0.9rem; color:#666;'>"
                "Necesitas al menos un triángulo para tener diagonales."
                "</span>"
            ))

    else:
        # Comprobamos convexidad una sola vez
        es_convexo = P.is_convex()   # rellena también P.convex_steps

        # ================== CASO CONVEXO ==================
        if es_convexo:
            pretty_print(html(
                "<h3 style='text-align:center;'>"
                "Polígono convexo: diagonales internas."
                "</h3>"
            ))

            # Usamos get_convex_diagonals si está definido, si no get_diagonals
            if hasattr(P, "get_convex_diagonals"):
                internas, externas = P.get_convex_diagonals()
            else:
                internas, externas = P.get_diagonals()

            set_internas = set(internas)
            ordered_diags = []

            for i in range(n):
                for j in range(i + 1, n):
                    # saltar lados
                    if j == i + 1:
                        continue
                    if i == 0 and j == n - 1:
                        continue

                    if (i, j) in set_internas:
                        a = pts[i]
                        b = pts[j]
                        mid = puntoMedio(a, b)
                        ordered_diags.append({"a": a, "b": b, "mid": mid})

            max_k = len(ordered_diags)

            @interact
            def applet_diagonales_convexas(
                k = slider(0, max_k, 1, default=0, label="Número de diagonales")
            ):
                # Polígono base en AZUL (como en el ejemplo del área)
                g  = polygon(pts, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
                g += line(pts + [pts[0]],
                          rgbcolor=(0.10, 0.20, 0.60),
                          thickness=1)

                # Dibujamos las primeras k diagonales internas (solo la línea verde)
                for i in range(k):
                    step = ordered_diags[i]
                    a, b = step["a"], step["b"]
                    # (mid existe pero NO se plotea)
                    g += line([a, b], color="green", thickness=2)

                show(g, aspect_ratio=1, axes=True, figsize=5)

                if k == 0:
                    msg = "Sin diagonales aún: mueve el deslizador para verlas en orden (0,2; 0,3; ...)."
                else:
                    msg = f"Mostrando {k} diagonal(es) interna(s) en verde."

                pretty_print(html(
                    f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
                ))


        # ================== CASO CÓNCAVO ==================
        else:
            pretty_print(html(
                "<h3 style='text-align:center;'>"
                "Polígono cóncavo: clasificación paso a paso de diagonales internas (verde) y externas (naranja)."
                "</h3>"
            ))

            internas, externas = P.get_diagonals()

            # Creamos un conjunto para clasificación rápida
            set_internas = set(internas)
            set_externas = set(externas)

            # Reconstruimos el ORDEN del método: pares (i,j) no adyacentes
            # en el mismo barrido que usaría get_diagonals: 0,2; 0,3; ...
            ordered_diags = []
            for i in range(n):
                for j in range(i + 1, n):
                    # saltar lados
                    if j == i + 1:
                        continue
                    if i == 0 and j == n - 1:
                        continue

                    if (i, j) in set_internas:
                        color_final = "green"
                    elif (i, j) in set_externas:
                        color_final = "orange"
                    else:
                        # no es diagonal válida (se descartó por cortes)
                        continue

                    a = pts[i]
                    b = pts[j]
                    mid = puntoMedio(a, b)

                    ordered_diags.append({
                        "a": a,
                        "b": b,
                        "mid": mid,
                        "color": color_final
                    })


            step_data = []
            for d in ordered_diags:
                a, b, mid, col = d["a"], d["b"], d["mid"], d["color"]

                step_data.append({"tipo": "diag",     "a": a, "b": b, "mid": mid, "color": col})
                step_data.append({"tipo": "mid",      "a": a, "b": b, "mid": mid, "color": col})
                step_data.append({"tipo": "classify", "a": a, "b": b, "mid": mid, "color": col})

            max_k = len(step_data)

            @interact
            def applet_diagonales_concavas(
                k = slider(0, max_k, 1, default=0, label="Paso")
            ):
                # Polígono base en AZUL (igual que el ejemplo del área)
                g  = polygon(pts, alpha=0.30, rgbcolor=(0.65, 0.75, 1.00))
                g += line(pts + [pts[0]],
                          rgbcolor=(0.10, 0.20, 0.60),
                          thickness=1)

                # Vamos pintando lo que ya se ha hecho hasta el paso k
                for i in range(k):
                    step = step_data[i]
                    a    = step["a"]
                    b    = step["b"]
                    mid  = step["mid"]
                    col  = step["color"]

                    if step["tipo"] == "diag":
                        # Solo la diagonal candidata, gris
                        g += line([a, b], color="gray", thickness=1)

                    elif step["tipo"] == "mid":
                        # Diagonal gris + punto medio rojo
                        g += line([a, b], color="gray", thickness=1)
                        g += point(mid, color="red", size=30)

                    elif step["tipo"] == "classify":
                        # Diagonal coloreada + punto medio rojo
                        g += line([a, b], color=col, thickness=2)
                        g += point(mid, color="red", size=30)

                show(g, aspect_ratio=1, axes=True, figsize=5)

                if k == 0:
                    msg = ("Sin pasos aún")
                else:
                    ultimo = step_data[k-1]
                    if ultimo["tipo"] == "classify":
                        msg = ("Última diagonal clasificada como "
                               f"<b>{'interna (verde)' if ultimo['color']=='green' else 'externa (naranja)'}</b>.")
                    elif ultimo["tipo"] == "mid":
                        msg = ("Se ha dibujado el punto medio de la diagonal candidata "
                               "(aún sin decidir si es interna o externa).")
                    else:
                        msg = "Probando una nueva diagonal candidata (solo el segmento gris)."

                pretty_print(html(
                    f"<div style='text-align:center; font-size:0.95rem;'>{msg}</div>"
                ))

  </script>
</div>
      </section>

      <section>
        <div class="card theory-card">
          <details class="theory-details">
            <summary class="theory-summary">
              <span class="theory-icon">a</span>
              <span class="theory-title">Aplicaciones de diagonales de un polígono</span>
              <span class="theory-chevron">▾</span>
            </summary>

            <div class="theory-content">

                <section>
                  <p>
                    El cálculo de diagonales internas es el paso básico para triangulación de polígonos, que luego se utiliza en el cálculo de áreas, integración sobre regiones planas o discretización en métodos numéricos. También se emplea para descomponer polígonos generales en piezas más simples (por ejemplo, polígonos monótonos) sobre las que es más fácil realizar búsqueda de puntos o problemas de visibilidad. En polígonos convexos, las diagonales permiten definir estructuras adicionales como grafos duales de triangulaciones y sirven de base para algoritmos de optimización geométrica.
                  </p>
                  <p>
                    <strong>Fuente:</strong>
                    <a href="https://www.cs.umd.edu/class/spring2020/cmsc754/Lects/lect05-triangulate.pdf"
                      target="_blank" rel="noopener noreferrer">
                      CSUMD: Polygon Triangulation Lecture
                    </a>
                  </p>
                </section>
            </div>
          </details>
        </div>
      </section>


<hr>

      <section>
        <h2>Generación de Informe</h2>
<p>
</p>

      </section>


<section>
  <div class="card">
    <div class="card-header">
      <div class="card-title">Applet 10 · Informe PDF </div>
      <span class="card-tag">Exportar</span>
    </div>

    <div class="card-body">
      <p>
        Este módulo genera un <b>informe PDF </b> del polígono a partir de una
        <b>lista de puntos</b> y de un <b>punto de consulta</b> \(q\).
        El informe incluye: convexidad, área, posición del punto respecto al polígono
        y tangentes desde \(q\).
      </p>
      <p>
        Introduce la lista de vértices en formato Python/Sage, por ejemplo
        <code>[(0,0),(2,0),(2,1),(0,1)]</code>, y el punto de estudio, por ejemplo, como
        <code>[3,3]</code>. El nombre que elijas aparecerá en la portada del PDF.
      </p>
    </div>

    <div class="compute-applet" id="applet9">
      <script type="text/x-sage">

from matplotlib.backends.backend_pdf import PdfPages
import matplotlib.pyplot as plt

def estudio_pdf_completo(lista_puntos, q,
                         nombre_poligono="Polígono sin nombre",
                         filename=None):

    # ---------- nombre de fichero ----------
    if filename is None:
        safe = "".join(ch if ch.isalnum() or ch in " _-" else "_" for ch in nombre_poligono)
        base_name = safe if safe else "Poligono"
        filename = "Informe_Completo_{}.pdf".format(base_name)

    # ---------- polígono base ----------
    P = Polygon(lista_puntos)
    pts = P.points
    n   = len(pts)
    q   = (RR(q[0]), RR(q[1]))

    if n < 3:
        raise ValueError("El polígono debe tener al menos 3 vértices.")

    xs = [p[0] for p in pts]
    ys = [p[1] for p in pts]
    xmin, xmax = min(xs), max(xs)
    ymin, ymax = min(ys), max(ys)
    R = max(xmax - xmin, ymax - ymin) or 1

    # rango común para todos los plots
    x_min_plot = xmin - 0.3*R
    x_max_plot = xmax + 0.3*R
    y_max_plot = ymax + 0.2*R
    y_min_plot = ymin - 0.3*R

    def ajustar(g):
        g.set_aspect_ratio(1)
        g.set_axes_range(x_min_plot, x_max_plot, y_min_plot, y_max_plot)
        return g

    def add_title(g, texto):
        # título dentro del gráfico, parte superior izquierda
        xpos = x_min_plot + 0.05*R
        ypos = y_max_plot - 0.08*R
        g += text(texto, (xpos, ypos),
                  fontsize=12, rgbcolor=(0,0,0))
        return g

    # =====================================================
    # CÁLCULOS GLOBALES
    # =====================================================

    # --- Convexidad ---
    es_convexo = P.is_convex()   # rellena P.convex_steps

    # --- Área (triangulación respecto al primer vértice) ---
    base = pts[0]
    step_data_area = []
    acum = 0
    for i in range(1, n-1):
        a = pts[i]
        b = pts[i+1]
        s = areaSignada(base, a, b)
        acum += s
        step_data_area.append(([base, a, b], s))
    area_signed = acum
    area_abs    = abs(acum)

    # --- Punto en polígono: convexo ---
    def test_convexo_point(P, q):
        Ppts = P.points
        n    = len(Ppts)
        tri_data = []
        ref = None
        sign_changed = False
        for i in range(n):
            a = Ppts[i]
            b = Ppts[(i+1) % n]
            s = areaSignada(a, b, q)

            if s == 0:
                col = "green"
                tri = [a, b, q]
                interior_hasta_aqui = not sign_changed
                tri_data.append((tri, col, interior_hasta_aqui))
                continue

            if ref is None:
                ref = s
            else:
                if ref * s < 0:
                    sign_changed = True

            col = "green" if s >= 0 else "orange"
            tri = [a, b, q]
            interior_hasta_aqui = not sign_changed
            tri_data.append((tri, col, interior_hasta_aqui))

            if sign_changed:
                break

        dentro = tri_data[-1][2] if tri_data else False
        return dentro, tri_data

    # --- Punto en polígono: no convexo (ray casting) ---
    def test_no_convexo_point(P, q):
        Ppts = P.points
        m = max(Ppts)
        M = [m[0] + 1, m[1] + 0.001]
        cont = 0
        lados_info = []
        for i in range(len(Ppts)):
            a = Ppts[i-1]
            b = Ppts[i]
            inter = testInterseccionSegmentos([M, q], [a, b])
            if inter:
                cont += 1
            lados_info.append((a, b, inter))
        dentro = (cont % 2 == 1)
        return dentro, (m, M, cont, lados_info)

    # Ejecutar test de punto en polígono
    if es_convexo:
        punto_interior, tri_data_pp = test_convexo_point(P, q)
        metodo_posicion = "test de convexidad"
        data_rc         = None
    else:
        punto_interior, data_rc = test_no_convexo_point(P, q)
        metodo_posicion = "ray casting"
        tri_data_pp     = None

    # --- Tangentes sobre cierre convexo ---
    if es_convexo:
        CP = ConvexPolygon(P.points)
    else:
        CP = P.convex_hull()

    hull_pts = CP.points
    n_h      = len(hull_pts)

    tangentes   = []   # lista de (v, ext)
    t_indices   = []   # índices del vértice en el polígono original
    dentro_hull = False

    if n_h >= 2:
        dentro_hull = CP.point_in_convex(q)
        if not dentro_hull:
            visited = set()
            for i in range(n_h):
                v_prev = hull_pts[i-1]
                v      = hull_pts[i]
                v_next = hull_pts[(i+1) % n_h]

                s1 = areaSignada(v_prev, v, q)
                s2 = areaSignada(v, v_next, q)

                left1 = (s1 >= 0)
                left2 = (s2 >= 0)
                es_tan_local = (left1 != left2)

                if es_tan_local:
                    key = (v[0], v[1])
                    if key not in visited:
                        visited.add(key)
                        qx, qy = q[0], q[1]
                        vx, vy = v[0], v[1]
                        dx = vx - qx
                        dy = vy - qy
                        factor = RR('0.6')
                        ext    = (vx + factor*dx, vy + factor*dy)
                        tangentes.append((v, ext))
                        # índice del vértice v en el polígono original pts
                        try:
                            idx_poly = pts.index(v)
                        except ValueError:
                            idx_poly = None
                        t_indices.append(idx_poly)
                        if len(tangentes) == 2:
                            break

    resumen_tangentes_breve = (
        "no definibles (cierre convexo con menos de 2 puntos)"
        if n_h < 2
        else (
            "no existen (punto interior al cierre convexo)"
            if dentro_hull else
            "{} tangente(s) exterior(es)".format(len(tangentes))
        )
    )

    # =====================================================
    # CONSTRUCCIÓN DE LOS GRÁFICOS (Sage Graphics)
    # =====================================================

    # 1) Polígono simple
    g_poly = polygon(pts,
                     alpha=0.40,
                     rgbcolor=(0.65, 0.75, 1.00))
    g_poly += line(pts + [pts[0]],
                   rgbcolor=(0.10, 0.20, 0.60),
                   thickness=2.5)
    g_poly += point(pts,
                    size=30,
                    rgbcolor=(0.10, 0.20, 0.80))
    g_poly = ajustar(g_poly)
    # g_poly = add_title(g_poly, "Polígono base")

    # 2) Convexidad
    g_conv = polygon(pts,
                     alpha=0.40,
                     rgbcolor=(0.65, 0.75, 1.00))
    g_conv += line(pts + [pts[0]],
                   rgbcolor=(0.10, 0.20, 0.60),
                   thickness=2.5)
    
    for idx, pt in enumerate(P.points):
        convex = P.is_convex_point(idx)
        col    = "green" if convex else "red"
        g_conv += point(pt, size=50, rgbcolor=col)
    g_conv = ajustar(g_conv)
    # g_conv = add_title(g_conv, "Análisis de convexidad")

    # 3) Área
    g_area = polygon(pts,
                     alpha=0.25,
                     rgbcolor=(0.65, 0.75, 1.00))
    g_area += line(pts + [pts[0]],
                   rgbcolor=(0.10, 0.20, 0.60),
                   thickness=2.5)
    for tri, s in step_data_area:
        col = "green" if s >= 0 else "orange"
        g_area += polygon(tri, alpha=0.40, color=col)
        g_area += line(tri + [tri[0]], color=col, thickness=2)
    g_area = ajustar(g_area)
    # g_area = add_title(g_area, "Área por triangulación")

    # 4) Punto en polígono
    if es_convexo:
        g_pp = polygon(pts,
                       alpha=0.30,
                       rgbcolor=(0.65, 0.75, 1.00))
        g_pp += line(pts + [pts[0]],
                     rgbcolor=(0.10, 0.20, 0.60),
                     thickness=2.5)
        g_pp += point([q], size=32, rgbcolor='red')
        for tri, col, _ in tri_data_pp:
            g_pp += polygon(tri, alpha=0.40, color=col)
            g_pp += line([q, tri[0]], color=col, thickness=2)
            g_pp += line([q, tri[1]], color=col, thickness=2)
    else:
        _, (m, M, cont, lados_info) = punto_interior, data_rc
        g_pp = polygon(pts,
                       alpha=0.30,
                       rgbcolor=(0.65, 0.75, 1.00))
        g_pp += line(pts + [pts[0]],
                     rgbcolor=(0.10, 0.20, 0.60),
                     thickness=2.5)
        g_pp += point([q], size=32, rgbcolor='red')
        g_pp += point(m, color="blue", size=24)
        g_pp += point(M, color="blue", size=24)
        g_pp += line([m, M], linestyle="--", rgbcolor="#666666")
        g_pp += line([M, q], color='black', linestyle="--", thickness=2)
        for (a, b, inter) in lados_info:
            col = 'orange' if inter else 'green'
            g_pp += line([a, b], color=col, thickness=2.2)
    g_pp = ajustar(g_pp)
    # g_pp = add_title(g_pp, "Punto en polígono ({})".format("interior" if punto_interior else "exterior"))

    # 5) Tangentes
    g_tan = polygon(pts,
                    alpha=0.25,
                    rgbcolor=(0.70, 0.80, 1.00))
    g_tan += line(pts + [pts[0]],
                  rgbcolor=(0.30, 0.40, 0.90),
                  thickness=2.5)
    g_tan += point([q], size=32, rgbcolor='red')
    if n_h >= 2:
        g_tan += polygon(hull_pts,
                         alpha=0.12,
                         rgbcolor=(0.20, 0.30, 0.70))
        g_tan += line(hull_pts + [hull_pts[0]],
                      rgbcolor=(0.10, 0.20, 0.60),
                      thickness=2)
    if not dentro_hull:
        for v, ext in tangentes:
            g_tan += line([q, ext],
                          rgbcolor=(0.90, 0.00, 0.90),
                          thickness=2.8)
            g_tan += point([v], size=36, rgbcolor=(0.90, 0.00, 0.90))
    g_tan = ajustar(g_tan)
    # g_tan = add_title(g_tan, "Tangentes desde el punto")

    paginas_plots = [g_poly, g_conv, g_area, g_pp, g_tan]

    # =====================================================
    # CREAR PDF 
    # =====================================================

    pp = PdfPages(filename)

    # --- Página 1: TEXTO ---
    fig = plt.figure(figsize=(8.27, 11.69))   # A4 vertical
    ax = fig.add_subplot(111)
    ax.axis('off')

    fig.text(0.5, 0.92, "Estudio del polígono",
             ha='center', va='top',
             fontsize=24, weight='bold')
    fig.text(0.5, 0.86, nombre_poligono,
             ha='center', va='top',
             fontsize=20, color='blue')

    fig.text(0.1, 0.74, "1. Datos de entrada",
             ha='left', va='top',
             fontsize=14, weight='bold')
    fig.text(0.1, 0.71,
             "· Número de vértices: {}\n"
             "· Punto de consulta: q = ({:.3f}, {:.3f})"
             .format(n, float(q[0]), float(q[1])),
             ha='left', va='top',
             fontsize=12)

    fig.text(0.1, 0.62, "2. Convexidad del polígono",
             ha='left', va='top',
             fontsize=14, weight='bold')
    fig.text(0.1, 0.59,
             "· El polígono es {}."
             .format("CONVEXO" if es_convexo else "NO CONVEXO"),
             ha='left', va='top',
             fontsize=12)

    fig.text(0.1, 0.51, "3. Área del polígono",
             ha='left', va='top',
             fontsize=14, weight='bold')
    fig.text(0.1, 0.48,
             "· Área signada: {:.4f}\n"
             "· Área geométrica (valor absoluto): {:.4f}"
             .format(float(area_signed), float(area_abs)),
             ha='left', va='top',
             fontsize=12)

    fig.text(0.1, 0.39, "4. Posición del punto respecto al polígono",
             ha='left', va='top',
             fontsize=14, weight='bold')
    fig.text(0.1, 0.36,
             "· Método utilizado: {}.\n"
             "· El punto de consulta es {} respecto al polígono."
             .format(metodo_posicion,
                     "INTERIOR" if punto_interior else "EXTERIOR"),
             ha='left', va='top',
             fontsize=12)

    fig.text(0.1, 0.27, "5. Tangentes desde el punto al polígono",
             ha='left', va='top',
             fontsize=14, weight='bold')

    y0 = 0.24
    fig.text(0.1, y0,
             "· {}.".format(resumen_tangentes_breve),
             ha='left', va='top',
             fontsize=12)
    y = y0 - 0.04

    if tangentes:
        for k, ((v, ext), idx_poly) in enumerate(zip(tangentes, t_indices), start=1):
            if idx_poly is not None:
                linea = ("  Tangente {}: vértice índice {} "
                         "con coordenadas ({:.3f}, {:.3f})."
                         ).format(k, idx_poly,
                                  float(v[0]), float(v[1]))
            else:
                linea = ("  Tangente {}: vértice con coordenadas "
                         "({:.3f}, {:.3f})."
                         ).format(k, float(v[0]), float(v[1]))
            fig.text(0.1, y, linea,
                     ha='left', va='top',
                     fontsize=11)
            y -= 0.03

    pp.savefig(fig)
    plt.close(fig)

    for g in paginas_plots:
        fig = g.matplotlib(figsize=(8.27, 11.69))
        for ax in fig.axes:
            ax.set_axis_off()
        pp.savefig(fig)
        plt.close(fig)

    pp.close()

    pretty_print(html(
        "<div style='font-size:0.95rem;'>"
        "Informe PDF completo generado: "
        f"<b>{filename}</b><br>"
        "Incluye texto en la primera página y una imagen por página después."
        "</div>"
    ))


@interact
def applet_informe_pdf(
    lista_puntos_str = input_box(
        "[(0,0),(2,0),(2,1),(0,1)]",
        label="Lista de vértices (x,y)",
        type=str
    ),

    q_str = input_box(
        "[3,3]",
        label="Punto q (x,y)",
        type=str
    ),

    nombre = input_box(
        "Polígono sin nombre",
        label="Nombre del polígono (para el PDF)",
        type=str
    ),

    accion = selector(
        ["Esperando…", "Generar informe PDF"],
        label="Acción"
    )
):

    # “Botón” simulado
    if accion == "Esperando…":
        pretty_print(html(
            "<span style='color:#666;'>"
            "Selecciona <b>Generar informe PDF</b> cuando estés listo."
            "</span>"
        ))
        return

    # Parseo de entradas
    try:
        lista_puntos = sage_eval(lista_puntos_str)
        q = sage_eval(q_str)
    except Exception as e:
        pretty_print(html(
            f"<span style='color:red;'>Error en la entrada (lista de puntos o q):<br>{e}</span>"
        ))
        return

    if len(lista_puntos) < 3:
        pretty_print(html(
            "<span style='color:red;'>El polígono debe tener al menos 3 vértices.</span>"
        ))
        return

    # Generar PDF
    try:
        filename = estudio_pdf_completo(
            lista_puntos, q,
            nombre_poligono = nombre
        )
    except Exception as e:
        pretty_print(html(
            f"<span style='color:red;'>Error al generar PDF:<br>{e}</span>"
        ))
        return
      </script>
    </div>

  </div>
</section>

      <section>
        <div class="card card--applet">
          <div class="card-header">
            <div class="card-title">Math-Canvas interactivo</div>
            <span class="card-tag">HTML5 Canvas</span>
          </div>
          <div class="card-body">
            <p>
              Interfaz en HTML5 que reproduce las ideas de los applets anteriores:
              poligonización (Graham, monótona en <i>x</i> o <i>y</i>, estrellada),
              análisis de convexidad y prueba de punto en polígono.
            </p>
          </div>

          <div class="math-canvas-wrapper">
            <!-- Controles arriba -->
            <div class="math-canvas-controls">
              <div class="math-canvas-toolbar">
                <div class="group">
                  <label for="poly-method">Método de cierre del polígono:</label>
                  <select id="poly-method">
                    <option value="graham">Graham (envolvente convexa)</option>
                    <option value="xmonotone">Monótono respecto a x</option>
                    <option value="ymonotone">Monótono respecto a y</option>
                    <option value="star">Estrellado</option>
                  </select>
                </div>

                <div class="group">
                  <label for="mode-select">Modo interactivo:</label>
                  <select id="mode-select">
                    <option value="build">Construir polígono</option>
                    <option value="point">Punto en polígono</option>
                    <option value="convexity">Convexidad</option>
                    <option value="tangent">Tangentes</option>
                  </select>

                </div>

                <div class="group">
                  <label>&nbsp;</label>
                  <div>
                    <button id="btn-close-polygon" class="primary">
                      Cerrar polígono
                    </button>
                    <button id="btn-reset">
                      Reiniciar
                    </button>
                  </div>
                </div>

                <div class="group">
                  <label>Convexidad:</label>
                  <button id="btn-analyze-convexity">
                    Analizar convexidad
                  </button>
                </div>
              </div>

              <div id="convexity-summary"
                   style="font-size:0.85rem; margin-top:4px;"></div>

              <div id="convexity-step-wrapper"
                   style="margin-top:6px; display:none;">
                <label for="convexity-step" style="font-size:0.8rem;">
                  Vértice (paso):
                </label>
                <input type="range" id="convexity-step"
                       min="0" value="0" step="1"
                       style="width:100%; margin-top:2px;">
              </div>

              <div class="math-canvas-status" id="math-canvas-status" style="margin-top:8px;">
                Modo actual: <b>construir polígono</b>. Haz clic en la zona inferior para añadir puntos.
                <br>Puntos clicados: <b>0</b>.
              </div>

              <p style="margin-top:8px; font-size:0.82rem;">
                • En modo <b>Construir polígono</b> los clics añaden puntos a la nube.<br>
                • Pulsa <b>Cerrar polígono</b> para aplicar la poligonización elegida.<br>
                • En modo <b>Punto en polígono</b>, los clics marcan un punto rojo (ray casting).<br>
                • En modo <b>Convexidad</b>, usa el deslizador para recorrer los vértices analizados.
              </p>
            </div>

            <!-- Canvas abajo, ocupando todo el ancho -->
            <div class="math-canvas-canvasbox">
              <canvas id="math-canvas" width="900" height="440"></canvas>
            </div>
          </div>
        </div>
      </section>



      <hr>
      <p style="font-size:0.8rem; color:var(--text-muted);">
        Modificado por última vez: dd/mm/aaaa.
      </p>
    </div>

<script>
  // ============================================================
  //  Math-Canvas interactivo
  //  - poligonización (Graham, x-monótona, y-monótona, estrellada)
  //  - modos: construir / punto en polígono / convexidad / tangentes
  //  - info extra: área del polígono
  // ============================================================
  window.addEventListener('DOMContentLoaded', function () {
    const canvas    = document.getElementById('math-canvas');
    const statusBox = document.getElementById('math-canvas-status');
    const btnClose  = document.getElementById('btn-close-polygon');
    const btnReset  = document.getElementById('btn-reset');
    const selMethod = document.getElementById('poly-method');
    const selMode   = document.getElementById('mode-select');

    const btnAnalyzeConvexity  = document.getElementById('btn-analyze-convexity');
    const convexitySummary     = document.getElementById('convexity-summary');
    const convexityStepWrapper = document.getElementById('convexity-step-wrapper');
    const convexityStepSlider  = document.getElementById('convexity-step');

    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    let rawPoints = [];
    let polygon   = [];
    let testPoint = null;
    let interactionMode = 'build'; // 'build' | 'point' | 'convexity' | 'tangent'

    let convexitySteps = [];
    let convexGlobal   = null;
    let convexStepIdx  = 0;

    // ---------- Utilidades geométricas ----------

    function area2(a, b, c) {
      return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    }

    function pointInPolygon(poly, pt) {
      if (!poly || poly.length < 3) return false;
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;

        const intersect =
          ((yi > pt.y) !== (yj > pt.y)) &&
          (pt.x < ((xj - xi) * (pt.y - yi) / (yj - yi) + xi));

        if (intersect) inside = !inside;
      }
      return inside;
    }

    function dist(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Transformación a coordenadas "matemáticas" [-3,3] para mostrar
    function logicalCoords(p) {
      const w = canvas.width;
      const h = canvas.height;
      const x = (p.x / w) * 6 - 3;          // [0,w] -> [-3,3]
      const y = ((h - p.y) / h) * 6 - 3;    // invertimos eje y
      return { x, y };
    }

    // Área signada del polígono
    function polygonSignedArea(poly) {
      if (!poly || poly.length < 3) return 0;
      let area = 0;
      const n = poly.length;
      for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        area += poly[i].x * poly[j].y - poly[j].x * poly[i].y;
      }
      return area / 2;
    }

    // ---------- Poligonizaciones ----------

    function grahamHull(points) {
      if (points.length <= 3) return [...points];
      const pts = [...points].sort((p, q) =>
        p.x === q.x ? p.y - q.y : p.x - q.x
      );
      const O = pts[0];
      const others = pts.slice(1).sort((p, q) => {
        const ang1 = Math.atan2(p.y - O.y, p.x - O.x);
        const ang2 = Math.atan2(q.y - O.y, q.x - O.x);
        if (ang1 === ang2) {
          const d1 = (p.x - O.x) ** 2 + (p.y - O.y) ** 2;
          const d2 = (q.x - O.x) ** 2 + (q.y - O.y) ** 2;
          return d1 - d2;
        }
        return ang1 - ang2;
      });
      const ordered = [O, ...others];
      const stack = [];
      for (const p of ordered) {
        while (stack.length >= 2 &&
               area2(stack[stack.length - 2], stack[stack.length - 1], p) < 0) {
          stack.pop();
        }
        stack.push(p);
      }
      return stack;
    }

    function xMonotone(points) {
      if (points.length < 3) return [...points];
      const P = [...points].sort((p, q) =>
        p.x === q.x ? p.y - q.y : p.x - q.x
      );
      const pmin = P[0];
      const pmax = P[P.length - 1];
      const Lsup = [], Linf = [];
      for (const punto of P) {
        if (area2(pmin, pmax, punto) >= 0) Lsup.push(punto);
        else Linf.push(punto);
      }
      return [...Linf, ...Lsup.reverse()];
    }

    function yMonotone(points) {
      if (points.length < 3) return [...points];
      const P = [...points].sort((p, q) =>
        p.y === q.y ? p.x - q.x : p.y - q.y
      );
      const pmin = P[0];
      const pmax = P[P.length - 1];
      const Lizq = [], Lder = [];
      for (const punto of P) {
        if (area2(pmin, pmax, punto) >= 0) Lizq.push(punto);
        else Lder.push(punto);
      }
      return [...Lder, ...Lizq.reverse()];
    }

    function starShaped(points) {
      if (points.length < 3) return [...points];
      let cx = 0, cy = 0;
      for (const p of points) { cx += p.x; cy += p.y; }
      cx /= points.length; cy /= points.length;
      const C = { x: cx, y: cy };
      return [...points].sort((p, q) => {
        const ang1 = Math.atan2(p.y - C.y, p.x - C.x);
        const ang2 = Math.atan2(q.y - C.y, q.x - C.x);
        if (ang1 === ang2) {
          const d1 = (p.x - C.x) ** 2 + (p.y - C.y) ** 2;
          const d2 = (q.x - C.x) ** 2 + (q.y - C.y) ** 2;
          return d1 - d2;
        }
        return ang1 - ang2;
      });
    }

    function buildPolygonFromRaw() {
      const method = selMethod ? selMethod.value : 'graham';
      if (rawPoints.length < 3) return [...rawPoints];
      if (method === 'graham')    return grahamHull(rawPoints);
      if (method === 'xmonotone') return xMonotone(rawPoints);
      if (method === 'ymonotone') return yMonotone(rawPoints);
      return starShaped(rawPoints);
    }

    // ---------- Convexidad (se detiene en el primer no convexo) ----------

    function computeConvexity(poly) {
      const n = poly.length;
      const steps = [];
      if (n < 3) return { isConvex: null, steps: [] };

      let firstSign = 0;
      let allConvex = true;

      for (let idx = 0; idx < n; idx++) {
        const vl = (idx - 1 + n) % n;
        const vr = (idx + 1) % n;
        const a = poly[vl];
        const b = poly[idx];
        const c = poly[vr];

        const s = area2(a, b, c);
        let convex = true;

        if (s !== 0) {
          const sign = s > 0 ? 1 : -1;
          if (firstSign === 0) {
            firstSign = sign;
          } else if (sign !== firstSign) {
            convex = false;
          }
        }

        steps.push({ idx, convex });
        if (!convex) {
          allConvex = false;
          // paramos en el primer vértice no convexo
          break;
        }
      }
      return { isConvex: allConvex, steps };
    }

    function resetConvexity() {
      convexitySteps = [];
      convexGlobal   = null;
      convexStepIdx  = 0;
      if (convexityStepWrapper) convexityStepWrapper.style.display = 'none';
      if (convexitySummary) convexitySummary.innerHTML = '';
    }

    // ---------- Tangentes (usando cierre convexo tipo Graham) ----------

    function computeTangentsForCurrent() {
      if (!polygon || polygon.length < 2 || !testPoint) {
        return { hull: null, tangents: [], pointInside: false };
      }

      const hull = grahamHull(polygon);
      const pointInside = pointInPolygon(hull, testPoint);
      if (pointInside) {
        return { hull, tangents: [], pointInside: true };
      }

      const n = hull.length;
      const tangents = [];
      const visited = new Set();

      for (let i = 0; i < n; i++) {
        const v_prev = hull[(i - 1 + n) % n];
        const v      = hull[i];
        const v_next = hull[(i + 1) % n];

        const s1 = area2(v_prev, v, testPoint);
        const s2 = area2(v, v_next, testPoint);

        const left1 = s1 >= 0;
        const left2 = s2 >= 0;
        const isTangent = (left1 !== left2);

        if (isTangent) {
          const key = v.x + ',' + v.y;
          if (!visited.has(key)) {
            visited.add(key);
            const qx = testPoint.x, qy = testPoint.y;
            const vx = v.x,        vy = v.y;
            const dx = vx - qx;
            const dy = vy - qy;
            const factor = 0.6;
            const ext = { x: vx + factor*dx, y: vy + factor*dy };
            tangents.push({ vertex: v, ext });
            if (tangents.length === 2) break;
          }
        }
      }

      return { hull, tangents, pointInside: false };
    }

    // ---------- Dibujo ----------

    function drawGrid() {
      const w = canvas.width;
      const h = canvas.height;
      const divs = 6; // para -3,-2,-1,1,2,3

      ctx.save();
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;

      const stepX = w / divs;
      const stepY = h / divs;

      for (let i = 1; i < divs; i++) {
        const x = i * stepX;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }

      for (let i = 1; i < divs; i++) {
        const y = i * stepY;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }

      ctx.restore();
    }

    function draw() {
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      drawGrid();

      const polyToDraw = polygon.length ? polygon : rawPoints;

      // Polígono / nube
      if (polyToDraw.length >= 2) {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(polyToDraw[0].x, polyToDraw[0].y);
        for (let i = 1; i < polyToDraw.length; i++) {
          ctx.lineTo(polyToDraw[i].x, polyToDraw[i].y);
        }
        if (polygon.length >= 3) ctx.closePath();
        ctx.fillStyle = 'rgba(96, 165, 250, 0.35)';
        ctx.strokeStyle = 'rgba(37, 99, 235, 0.9)';
        ctx.lineWidth = 2;
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }

      // vértices
      ctx.save();
      for (const p of polyToDraw) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
        ctx.fillStyle = '#1d4ed8';
        ctx.fill();
      }
      ctx.restore();

      // Convexidad: solo en modo convexity
      if (interactionMode === 'convexity' &&
          polygon.length >= 3 &&
          convexitySteps.length > 0) {

        const n = polygon.length;
        const step = convexitySteps[Math.min(convexStepIdx, convexitySteps.length - 1)];
        const idx = step.idx;
        const vl = (idx - 1 + n) % n;
        const vr = (idx + 1) % n;

        const a = polygon[vl];
        const b = polygon[idx];
        const c = polygon[vr];
        const color = step.convex ? '#16a34a' : '#dc2626';

        ctx.save();
        ctx.lineWidth = 3;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.lineTo(c.x, c.y);
        ctx.stroke();

        function bigPoint(p, fill) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 7, 0, 2 * Math.PI);
          ctx.fillStyle = fill;
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'white';
          ctx.stroke();
        }

        bigPoint(a, '#1d4ed8');
        bigPoint(c, '#1d4ed8');
        bigPoint(b, color);
        ctx.restore();
      }

      // Punto en polígono (modo POINT) con rayo tipo Sage m -> M -> q
      if (interactionMode === 'point' &&
          testPoint && polygon.length >= 3) {

        const inside = pointInPolygon(polygon, testPoint);

        // 1) vértice con mayor abscisa (m)
        let m = polygon[0];
        for (const p of polygon) {
          if (p.x > m.x || (p.x === m.x && p.y > m.y)) {
            m = p;
          }
        }

        // 2) punto M = m + (1, 0.01) en coordenadas de pantalla
        const M = {
          x: m.x + 80,                  // desplazamiento visible en x
          y: m.y - canvas.height*0.01  // pequeño desplazamiento en y
        };

        // dibujamos m y M
        ctx.save();
        ctx.beginPath();
        ctx.arc(m.x, m.y, 5, 0, 2*Math.PI);
        ctx.fillStyle = '#1d4ed8';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(M.x, M.y, 5, 0, 2*Math.PI);
        ctx.fillStyle = '#1d4ed8';
        ctx.fill();
        ctx.restore();

        // segmento m–M
        ctx.save();
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(m.x, m.y);
        ctx.lineTo(M.x, M.y);
        ctx.stroke();
        ctx.restore();

        // rayo M–q
        ctx.save();
        ctx.setLineDash([6, 4]);
        ctx.strokeStyle = '#4b5563';
        ctx.lineWidth = 1.8;
        ctx.beginPath();
        ctx.moveTo(M.x, M.y);
        ctx.lineTo(testPoint.x, testPoint.y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        // punto q
        ctx.save();
        ctx.beginPath();
        ctx.arc(testPoint.x, testPoint.y, 6, 0, 2 * Math.PI);
        ctx.fillStyle = inside ? '#16a34a' : '#dc2626';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'white';
        ctx.stroke();
        ctx.restore();
      }

      // Tangentes (modo TANGENT)
      if (interactionMode === 'tangent' &&
          polygon.length >= 2 &&
          testPoint) {

        const { hull, tangents, pointInside } = computeTangentsForCurrent();

        if (hull && hull.length >= 2) {
          // dibujamos el cierre convexo
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(hull[0].x, hull[0].y);
          for (let i = 1; i < hull.length; i++) {
            ctx.lineTo(hull[i].x, hull[i].y);
          }
          ctx.closePath();
          ctx.strokeStyle = '#0f172a';
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 3]);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        }

        // punto q
        ctx.save();
        ctx.beginPath();
        ctx.arc(testPoint.x, testPoint.y, 6, 0, 2*Math.PI);
        ctx.fillStyle = pointInside ? '#dc2626' : '#16a34a';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'white';
        ctx.stroke();
        ctx.restore();

        if (!pointInside) {
          ctx.save();
          ctx.strokeStyle = '#a855f7';
          ctx.lineWidth = 2;
          for (const t of tangents) {
            ctx.beginPath();
            ctx.moveTo(testPoint.x, testPoint.y);
            ctx.lineTo(t.ext.x, t.ext.y);
            ctx.stroke();

            // vértice de tangencia
            ctx.beginPath();
            ctx.arc(t.vertex.x, t.vertex.y, 6, 0, 2*Math.PI);
            ctx.fillStyle = '#a855f7';
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#a855f7';
            ctx.stroke();
          }
          ctx.restore();
        }
      }
    }

    // ---------- Estado ----------

    function updateStatus() {
      if (!statusBox) return;

      const nRaw = rawPoints.length;
      const nPoly = polygon.length;

      let modoTxt;
      if (interactionMode === 'build')      modoTxt = 'construir polígono';
      else if (interactionMode === 'point') modoTxt = 'punto en polígono';
      else if (interactionMode === 'convexity') modoTxt = 'convexidad';
      else modoTxt = 'tangentes';

      let html = `Modo actual: <b>${modoTxt}</b>. `;
      if (interactionMode === 'build') {
        html += 'Haz clic en la zona inferior para añadir puntos.';
      } else if (interactionMode === 'point') {
        html += 'Haz clic en la zona inferior para colocar puntos rojos.';
      } else if (interactionMode === 'convexity') {
        html += 'Usa el botón "Analizar convexidad" y luego el deslizador.';
      } else {
        html += 'Haz clic para elegir un punto exterior y ver las tangentes.';
      }

      html += `<br>Puntos clicados: <b>${nRaw}</b>.`;
      if (nPoly >= 3) {
        const area = polygonSignedArea(polygon);
        const areaAbs = Math.abs(area);
        html += ` Polígono con <b>${nPoly}</b> vértices. `
              + `Área signada: <b>${area.toFixed(2)}</b>, `
              + `área: <b>${areaAbs.toFixed(2)}</b>.`;
      }

      const method = selMethod ? selMethod.value : 'graham';
      const nombre = method === 'graham'
        ? 'Graham (envolvente convexa)'
        : method === 'xmonotone'
          ? 'monótono respecto a x'
          : method === 'ymonotone'
            ? 'monótono respecto a y'
            : 'estrellado';
      html += `<br>Método de cierre seleccionado: <b>${nombre}</b>.`;

      if (testPoint && polygon.length >= 3) {
        const lc = logicalCoords(testPoint);
        const inside = pointInPolygon(polygon, testPoint);
        const pos = inside ? 'INTERIOR' : 'EXTERIOR';
        html += `<br>Último punto: <b>(${lc.x.toFixed(2)}, ${lc.y.toFixed(2)})</b> `
              + `en escala [-3,3]. Respecto al polígono: <b>${pos}</b>.`;
      }

      // info extra para modo tangentes
      if (interactionMode === 'tangent' && polygon.length >= 3 && testPoint) {
        const { hull, tangents, pointInside } = computeTangentsForCurrent();
        if (!hull) {
          html += '<br>No hay cierre convexo definido.';
        } else if (pointInside) {
          html += '<br>El punto está en el interior del cierre convexo: no hay tangentes exteriores.';
        } else {
          html += `<br>Tangentes encontradas: <b>${tangents.length}</b>.`;
        }
      }

      statusBox.innerHTML = html;

      if (convexitySummary) {
        if (convexGlobal === null) {
          convexitySummary.innerHTML = '';
        } else {
          const txt = convexGlobal ? 'Polígono <b>CONVEXO</b>.' : 'Polígono <b>NO CONVEXO</b>.';
          convexitySummary.innerHTML = txt +
            (convexitySteps.length
              ? ` (se ha detectado en el vértice ${convexitySteps[convexitySteps.length-1].idx + 1}).`
              : '');
        }
      }
    }

    // ---------- Eventos ----------

    canvas.addEventListener('click', ev => {
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const point = { x, y };

      if (interactionMode === 'build') {
        if (rawPoints.length === 0 ||
            dist(point, rawPoints[rawPoints.length - 1]) > 3) {
          rawPoints.push(point);
        }
        polygon = [];
        testPoint = null;
        resetConvexity();
      } else if (interactionMode === 'point' || interactionMode === 'tangent') {
        if (polygon.length < 3) {
          alert('Primero construye y cierra un polígono.');
          return;
        }
        testPoint = point;
      }
      draw();
      updateStatus();
    });

    if (btnClose) {
      btnClose.addEventListener('click', () => {
        if (rawPoints.length < 3) {
          alert('Necesitas al menos 3 puntos para formar un polígono.');
          return;
        }
        polygon = buildPolygonFromRaw();
        testPoint = null;
        resetConvexity();
        draw();
        updateStatus();
      });
    }

    if (btnReset) {
      btnReset.addEventListener('click', () => {
        rawPoints = [];
        polygon   = [];
        testPoint = null;
        interactionMode = 'build';
        if (selMode) selMode.value = 'build';
        resetConvexity();
        draw();
        updateStatus();
      });
    }

    if (selMode) {
      selMode.addEventListener('change', () => {
        interactionMode = selMode.value;
        if (interactionMode === 'convexity' &&
            convexitySteps.length > 0 &&
            convexityStepWrapper) {
          convexityStepWrapper.style.display = 'block';
        } else if (convexityStepWrapper) {
          convexityStepWrapper.style.display = 'none';
        }
        draw();
        updateStatus();
      });
    }

    if (btnAnalyzeConvexity) {
      btnAnalyzeConvexity.addEventListener('click', () => {
        if (polygon.length < 3) {
          alert('Primero construye y cierra un polígono (al menos 3 vértices).');
          return;
        }
        const res = computeConvexity(polygon);
        convexitySteps = res.steps;
        convexGlobal   = res.isConvex;
        convexStepIdx  = 0;

        if (convexitySteps.length > 0 && convexityStepWrapper && convexityStepSlider) {
          convexityStepWrapper.style.display = 'block';
          convexityStepSlider.min = 0;
          convexityStepSlider.max = convexitySteps.length - 1;
          convexityStepSlider.value = 0;
        }
        interactionMode = 'convexity';
        if (selMode) selMode.value = 'convexity';

        draw();
        updateStatus();
      });
    }

    if (convexityStepSlider) {
      convexityStepSlider.addEventListener('input', () => {
        convexStepIdx = parseInt(convexityStepSlider.value, 10) || 0;
        draw();
      });
    }

    draw();
    updateStatus();
  });
</script>

  </body>
</html>
